{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as types from '~/components/LadderGame.type';\nexport const defaultOption = {\n  mapMinHeight: 300\n};\nexport const LadderGameInitialState = {\n  hasMapData: false,\n  mapData: [],\n  mapWidth: 0,\n  mapHeight: defaultOption.mapMinHeight,\n  ladderBlockCnt: 21,\n  midLineData: [],\n  generatingMidLinePoint: null,\n  gameStep: 0,\n  completedLineIndexs: [],\n  rewards: []\n};\nexport const LadderGameInitializer = state => {\n  for (const key in state) {\n    Array.isArray(state[key]) && state[key].splice(0, state[key].length);\n  }\n\n  return state;\n};\nlet __uid = 0;\nexport const LadderGameReducer = (state, action) => {\n  switch (action.type) {\n    case types.CREATE_MAP_DATA:\n      {\n        const ladderQty = action.payload.ladderQty;\n\n        for (let x = 0; x < ladderQty; x++) {\n          state.mapData[x] = [];\n\n          for (let y = 0; y < state.ladderBlockCnt; y++) {\n            state.mapData[x][y] = {\n              uid: ++__uid,\n              el: null,\n              x,\n              y,\n              isHandle: false,\n              isLinked: false,\n              prevBlock: null,\n              nextBlock: null,\n              linkedBlock: null,\n              midLine: null\n            };\n\n            if (y > 0) {\n              const prev = state.mapData[x][y - 1];\n              prev.nextBlock = state.mapData[x][y];\n              state.mapData[x][y].prevBlock = prev;\n            }\n\n            if (y > 0 && y < state.ladderBlockCnt - 1) {\n              state.mapData[x][y].isHandle = y % 2 !== 0;\n            }\n          }\n        }\n\n        if (Array.isArray(state.mapData)) {\n          state.mapData.splice(0, state.mapData.length, ...state.mapData);\n        }\n\n        return _objectSpread({}, state, {\n          hasMapData: state.mapData.length > 0\n        });\n      }\n\n    case types.UPDATE_MAP_SIZE:\n      {\n        var _ref, _action$payload, _ref2, _action$payload2;\n\n        const mapWidth = (_ref = (_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.mapWidth) !== null && _ref !== void 0 ? _ref : 0;\n        const mapHeight = Math.max(state.mapHeight, (_ref2 = (_action$payload2 = action.payload) === null || _action$payload2 === void 0 ? void 0 : _action$payload2.mapHeight) !== null && _ref2 !== void 0 ? _ref2 : 0);\n        return _objectSpread({}, state, {\n          mapWidth,\n          mapHeight\n        });\n      }\n\n    case types.START_GENERATING_MIDLINE:\n      {\n        const generatingMidLinePoint = action.payload.startPoint;\n        return _objectSpread({}, state, {\n          generatingMidLinePoint\n        });\n      }\n\n    case types.CANCEL_GENERATING_MIDLINE:\n      {\n        return _objectSpread({}, state, {\n          generatingMidLinePoint: null\n        });\n      }\n\n    case types.FINISH_GENERATING_MIDLINE:\n      {\n        var _state$generatingMidL, _action$payload$endPo;\n\n        const startPoint = (_state$generatingMidL = state.generatingMidLinePoint) !== null && _state$generatingMidL !== void 0 ? _state$generatingMidL : null;\n        const endPoint = (_action$payload$endPo = action.payload.endPoint) !== null && _action$payload$endPo !== void 0 ? _action$payload$endPo : null;\n        const midLine = {\n          uid: ++__uid,\n          el: null,\n          blocks: []\n        };\n\n        if (startPoint && endPoint) {\n          // startPoint, endPoint 서로 연결\n          startPoint.isLinked = true;\n          endPoint.isLinked = true;\n          startPoint.linkedBlock = endPoint;\n          endPoint.linkedBlock = startPoint;\n          startPoint.midLine = midLine;\n          endPoint.midLine = midLine;\n          midLine.blocks = [startPoint, endPoint]; // state에 저장\n\n          state.midLineData.push(midLine);\n          state.generatingMidLinePoint = null;\n        }\n\n        return _objectSpread({}, state);\n      }\n\n    case types.REMOVE_MIDLINE:\n      {\n        const midLineIndex = action.payload.midLineIndex;\n\n        if (state.midLineData[midLineIndex]) {\n          state.midLineData[midLineIndex].blocks.forEach(row => {\n            row.isLinked = false;\n            row.linkedBlock = null;\n            row.midLine = null;\n          });\n          state.midLineData.splice(midLineIndex, 1);\n        }\n\n        return _objectSpread({}, state);\n      }\n\n    case types.PREPARE_GAME:\n      {\n        const rewards = action.payload.rewards;\n        state.gameStep = 1;\n        state.rewards = [...rewards].sort(() => Math.random() - Math.random());\n        return _objectSpread({}, state);\n      }\n\n    case types.PLAY_GAME:\n      {\n        const lineIndex = action.payload.lineIndex;\n        state.completedLineIndexs.push(lineIndex);\n\n        if (state.completedLineIndexs.length === state.mapData.length) {\n          state.gameStep = 2;\n        }\n\n        return _objectSpread({}, state);\n      }\n\n    case types.RE_GAME:\n      {\n        const prevMidLineData = state.midLineData.splice(0, state.midLineData.length);\n        state.generatingMidLinePoint = null;\n        state.gameStep = 0;\n        state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n        prevMidLineData.forEach(mapData => {\n          mapData.blocks.forEach(block => {\n            block.isLinked = false;\n            block.linkedBlock = null;\n          });\n        });\n        return _objectSpread({}, state);\n      }\n\n    case types.RESET:\n      {\n        state.hasMapData = false;\n        state.mapData.splice(0, state.mapData.length);\n        state.mapWidth = 0;\n        state.mapHeight = defaultOption.mapMinHeight;\n        state.ladderBlockCnt = 21;\n        state.midLineData.splice(0, state.midLineData.length);\n        state.generatingMidLinePoint = null;\n        state.gameStep = 0;\n        state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n        return _objectSpread({}, state);\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n};\nexport default LadderGameReducer;","map":null,"metadata":{},"sourceType":"module"}