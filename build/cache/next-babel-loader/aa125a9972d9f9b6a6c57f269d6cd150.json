{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as types from '~/components/LadderGame.type';\nexport const defaultOption = {\n  mapMinHeight: 300\n};\nexport const LadderGameInitialState = {\n  hasMapData: false,\n  mapData: [],\n  mapWidth: 0,\n  mapHeight: defaultOption.mapMinHeight,\n  ladderBlockCnt: 21,\n  midLineData: [],\n  generatingMidLinePoint: null,\n  gameStep: 0,\n  completedLineIndexs: [],\n  rewards: []\n};\nexport const LadderGameInitializer = state => {\n  for (const key in state) {\n    Array.isArray(state[key]) && state[key].splice(0, state[key].length);\n  }\n\n  return state;\n};\nlet __uid = 0;\nexport const LadderGameReducer = (state, action) => {\n  switch (action.type) {\n    case types.CREATE_MAP_DATA:\n      {\n        const ladderQty = action.payload.ladderQty;\n\n        for (let x = 0; x < ladderQty; x++) {\n          state.mapData[x] = [];\n\n          for (let y = 0; y < state.ladderBlockCnt; y++) {\n            state.mapData[x][y] = {\n              uid: ++__uid,\n              el: null,\n              x,\n              y,\n              isHandle: false,\n              isLinked: false,\n              prevBlock: null,\n              nextBlock: null,\n              linkedBlock: null,\n              midLine: null\n            };\n\n            if (y > 0) {\n              const prev = state.mapData[x][y - 1];\n              prev.nextBlock = state.mapData[x][y];\n              state.mapData[x][y].prevBlock = prev;\n            }\n\n            if (y > 0 && y < state.ladderBlockCnt - 1) {\n              state.mapData[x][y].isHandle = y % 2 !== 0;\n            }\n          }\n        }\n\n        if (Array.isArray(state.mapData)) {\n          state.mapData.splice(0, state.mapData.length, ...state.mapData);\n        }\n\n        return _objectSpread({}, state, {\n          hasMapData: state.mapData.length > 0\n        });\n      }\n\n    case types.UPDATE_MAP_SIZE:\n      {\n        var _ref, _action$payload, _ref2, _action$payload2;\n\n        const mapWidth = (_ref = (_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.mapWidth) !== null && _ref !== void 0 ? _ref : 0;\n        const mapHeight = Math.max(state.mapHeight, (_ref2 = (_action$payload2 = action.payload) === null || _action$payload2 === void 0 ? void 0 : _action$payload2.mapHeight) !== null && _ref2 !== void 0 ? _ref2 : 0);\n        return _objectSpread({}, state, {\n          mapWidth,\n          mapHeight\n        });\n      }\n\n    case types.START_GENERATING_MIDLINE:\n      {\n        const generatingMidLinePoint = action.payload.startPoint;\n        return _objectSpread({}, state, {\n          generatingMidLinePoint\n        });\n      }\n\n    case types.CANCEL_GENERATING_MIDLINE:\n      {\n        return _objectSpread({}, state, {\n          generatingMidLinePoint: null\n        });\n      }\n\n    case types.FINISH_GENERATING_MIDLINE:\n      {\n        var _state$generatingMidL, _action$payload$endPo;\n\n        const startPoint = (_state$generatingMidL = state.generatingMidLinePoint) !== null && _state$generatingMidL !== void 0 ? _state$generatingMidL : null;\n        const endPoint = (_action$payload$endPo = action.payload.endPoint) !== null && _action$payload$endPo !== void 0 ? _action$payload$endPo : null;\n        const midLine = {\n          uid: ++__uid,\n          el: null,\n          blocks: []\n        };\n\n        if (startPoint && endPoint) {\n          // startPoint, endPoint 서로 연결\n          startPoint.isLinked = true;\n          endPoint.isLinked = true;\n          startPoint.linkedBlock = endPoint;\n          endPoint.linkedBlock = startPoint;\n          startPoint.midLine = midLine;\n          endPoint.midLine = midLine;\n          midLine.blocks = [startPoint, endPoint]; // state에 저장\n\n          state.midLineData.push(midLine);\n          state.generatingMidLinePoint = null;\n        }\n\n        return _objectSpread({}, state);\n      }\n\n    case types.REMOVE_MIDLINE:\n      {\n        const midLineIndex = action.payload.midLineIndex;\n\n        if (state.midLineData[midLineIndex]) {\n          state.midLineData[midLineIndex].blocks.forEach(row => {\n            row.isLinked = false;\n            row.linkedBlock = null;\n            row.midLine = null;\n          });\n          state.midLineData.splice(midLineIndex, 1);\n        }\n\n        return _objectSpread({}, state);\n      }\n\n    case types.PREPARE_GAME:\n      {\n        const rewards = action.payload.rewards;\n        state.gameStep = 1;\n        state.rewards = [...rewards].sort(() => Math.random() - Math.random());\n        return _objectSpread({}, state);\n      }\n\n    case types.PLAY_GAME:\n      {\n        const lineIndex = action.payload.lineIndex;\n        state.completedLineIndexs.push(lineIndex);\n\n        if (state.completedLineIndexs.length === state.mapData.length) {\n          state.gameStep = 2;\n        }\n\n        return _objectSpread({}, state);\n      }\n\n    case types.RE_GAME:\n      {\n        const prevMidLineData = state.midLineData.splice(0, state.midLineData.length);\n        state.generatingMidLinePoint = null;\n        state.gameStep = 0;\n        state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n        prevMidLineData.forEach(mapData => {\n          mapData.blocks.forEach(block => {\n            block.isLinked = false;\n            block.linkedBlock = null;\n          });\n        });\n        return _objectSpread({}, state);\n      }\n\n    case types.RESET:\n      {\n        state.hasMapData = false;\n        state.mapData.splice(0, state.mapData.length);\n        state.mapWidth = 0;\n        state.mapHeight = defaultOption.mapMinHeight;\n        state.ladderBlockCnt = 21;\n        state.midLineData.splice(0, state.midLineData.length);\n        state.generatingMidLinePoint = null;\n        state.gameStep = 0;\n        state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n        return _objectSpread({}, state);\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n};\nexport default LadderGameReducer;","map":{"version":3,"sources":["/Users/chad/_workspace/ladder-game/components/LadderGame.reducer.tsx"],"names":["types","defaultOption","mapMinHeight","LadderGameInitialState","hasMapData","mapData","mapWidth","mapHeight","ladderBlockCnt","midLineData","generatingMidLinePoint","gameStep","completedLineIndexs","rewards","LadderGameInitializer","state","key","Array","isArray","splice","length","__uid","LadderGameReducer","action","type","CREATE_MAP_DATA","ladderQty","payload","x","y","uid","el","isHandle","isLinked","prevBlock","nextBlock","linkedBlock","midLine","prev","UPDATE_MAP_SIZE","Math","max","START_GENERATING_MIDLINE","startPoint","CANCEL_GENERATING_MIDLINE","FINISH_GENERATING_MIDLINE","endPoint","blocks","push","REMOVE_MIDLINE","midLineIndex","forEach","row","PREPARE_GAME","sort","random","PLAY_GAME","lineIndex","RE_GAME","prevMidLineData","block","RESET"],"mappings":";;;;;;AACA,OAAO,KAAKA,KAAZ,MAAuB,8BAAvB;AAEA,OAAO,MAAMC,aAAa,GAAG;AACzBC,EAAAA,YAAY,EAAE;AADW,CAAtB;AAIP,OAAO,MAAMC,sBAA6B,GAAG;AACzCC,EAAAA,UAAU,EAAE,KAD6B;AAEzCC,EAAAA,OAAO,EAAE,EAFgC;AAGzCC,EAAAA,QAAQ,EAAE,CAH+B;AAIzCC,EAAAA,SAAS,EAAEN,aAAa,CAACC,YAJgB;AAKzCM,EAAAA,cAAc,EAAE,EALyB;AAMzCC,EAAAA,WAAW,EAAE,EAN4B;AAOzCC,EAAAA,sBAAsB,EAAE,IAPiB;AAQzCC,EAAAA,QAAQ,EAAE,CAR+B;AASzCC,EAAAA,mBAAmB,EAAE,EAToB;AAUzCC,EAAAA,OAAO,EAAE;AAVgC,CAAtC;AAaP,OAAO,MAAMC,qBAAqB,GAAIC,KAAD,IAAkB;AACnD,OAAK,MAAMC,GAAX,IAAkBD,KAAlB,EAAyB;AACrBE,IAAAA,KAAK,CAACC,OAAN,CAAcH,KAAK,CAACC,GAAD,CAAnB,KAA6BD,KAAK,CAACC,GAAD,CAAL,CAAWG,MAAX,CAAkB,CAAlB,EAAqBJ,KAAK,CAACC,GAAD,CAAL,CAAWI,MAAhC,CAA7B;AACH;;AACD,SAAOL,KAAP;AACH,CALM;AAOP,IAAIM,KAAK,GAAG,CAAZ;AAEA,OAAO,MAAMC,iBAAiB,GAAG,CAACP,KAAD,EAAeQ,MAAf,KAAyD;AACtF,UAAQA,MAAM,CAACC,IAAf;AACI,SAAKxB,KAAK,CAACyB,eAAX;AAA4B;AACxB,cAAMC,SAAiB,GAAGH,MAAM,CAACI,OAAP,CAAeD,SAAzC;;AAGA,aAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAApB,EAA+BE,CAAC,EAAhC,EAAoC;AAChCb,UAAAA,KAAK,CAACV,OAAN,CAAcuB,CAAd,IAAmB,EAAnB;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,KAAK,CAACP,cAA1B,EAA0CqB,CAAC,EAA3C,EAA+C;AAC3Cd,YAAAA,KAAK,CAACV,OAAN,CAAcuB,CAAd,EAAiBC,CAAjB,IAAuB;AACnBC,cAAAA,GAAG,EAAE,EAAET,KADY;AAEnBU,cAAAA,EAAE,EAAE,IAFe;AAGnBH,cAAAA,CAHmB;AAInBC,cAAAA,CAJmB;AAKnBG,cAAAA,QAAQ,EAAE,KALS;AAMnBC,cAAAA,QAAQ,EAAE,KANS;AAOnBC,cAAAA,SAAS,EAAE,IAPQ;AAQnBC,cAAAA,SAAS,EAAE,IARQ;AASnBC,cAAAA,WAAW,EAAE,IATM;AAUnBC,cAAAA,OAAO,EAAE;AAVU,aAAvB;;AAaA,gBAAIR,CAAC,GAAG,CAAR,EAAW;AACP,oBAAMS,IAAI,GAAGvB,KAAK,CAACV,OAAN,CAAcuB,CAAd,EAAiBC,CAAC,GAAG,CAArB,CAAb;AACAS,cAAAA,IAAI,CAACH,SAAL,GAAiBpB,KAAK,CAACV,OAAN,CAAcuB,CAAd,EAAiBC,CAAjB,CAAjB;AACAd,cAAAA,KAAK,CAACV,OAAN,CAAcuB,CAAd,EAAiBC,CAAjB,EAAoBK,SAApB,GAAgCI,IAAhC;AACH;;AAED,gBAAIT,CAAC,GAAG,CAAJ,IAASA,CAAC,GAAGd,KAAK,CAACP,cAAN,GAAuB,CAAxC,EAA2C;AACvCO,cAAAA,KAAK,CAACV,OAAN,CAAcuB,CAAd,EAAiBC,CAAjB,EAAoBG,QAApB,GAA+BH,CAAC,GAAG,CAAJ,KAAU,CAAzC;AACH;AACJ;AACJ;;AAED,YAAIZ,KAAK,CAACC,OAAN,CAAcH,KAAK,CAACV,OAApB,CAAJ,EAAkC;AAC9BU,UAAAA,KAAK,CAACV,OAAN,CAAcc,MAAd,CAAqB,CAArB,EAAwBJ,KAAK,CAACV,OAAN,CAAce,MAAtC,EAA8C,GAAGL,KAAK,CAACV,OAAvD;AACH;;AAED,iCACOU,KADP;AAEIX,UAAAA,UAAU,EAAEW,KAAK,CAACV,OAAN,CAAce,MAAd,GAAuB;AAFvC;AAIH;;AAED,SAAKpB,KAAK,CAACuC,eAAX;AAA4B;AAAA;;AACxB,cAAMjC,QAAQ,8BAAGiB,MAAM,CAACI,OAAV,oDAAG,gBAAgBrB,QAAnB,uCAA+B,CAA7C;AACA,cAAMC,SAAS,GAAGiC,IAAI,CAACC,GAAL,CAAS1B,KAAK,CAACR,SAAf,+BAA0BgB,MAAM,CAACI,OAAjC,qDAA0B,iBAAgBpB,SAA1C,yCAAuD,CAAvD,CAAlB;AAEA,iCACOQ,KADP;AAEIT,UAAAA,QAFJ;AAGIC,UAAAA;AAHJ;AAKH;;AAED,SAAKP,KAAK,CAAC0C,wBAAX;AAAqC;AACjC,cAAMhC,sBAAsB,GAAGa,MAAM,CAACI,OAAP,CAAegB,UAA9C;AAEA,iCACO5B,KADP;AAEIL,UAAAA;AAFJ;AAIH;;AAED,SAAKV,KAAK,CAAC4C,yBAAX;AAAsC;AAClC,iCACO7B,KADP;AAEIL,UAAAA,sBAAsB,EAAE;AAF5B;AAIH;;AAED,SAAKV,KAAK,CAAC6C,yBAAX;AAAsC;AAAA;;AAClC,cAAMF,UAA0B,4BAAG5B,KAAK,CAACL,sBAAT,yEAAmC,IAAnE;AACA,cAAMoC,QAAwB,4BAAGvB,MAAM,CAACI,OAAP,CAAemB,QAAlB,yEAA8B,IAA5D;AAEA,cAAMT,OAAgB,GAAG;AACrBP,UAAAA,GAAG,EAAE,EAAET,KADc;AAErBU,UAAAA,EAAE,EAAE,IAFiB;AAGrBgB,UAAAA,MAAM,EAAE;AAHa,SAAzB;;AAMA,YAAIJ,UAAU,IAAIG,QAAlB,EAA4B;AAExB;AACAH,UAAAA,UAAU,CAACV,QAAX,GAAsB,IAAtB;AACAa,UAAAA,QAAQ,CAACb,QAAT,GAAoB,IAApB;AACAU,UAAAA,UAAU,CAACP,WAAX,GAAyBU,QAAzB;AACAA,UAAAA,QAAQ,CAACV,WAAT,GAAuBO,UAAvB;AACAA,UAAAA,UAAU,CAACN,OAAX,GAAqBA,OAArB;AACAS,UAAAA,QAAQ,CAACT,OAAT,GAAmBA,OAAnB;AACAA,UAAAA,OAAO,CAACU,MAAR,GAAiB,CAACJ,UAAD,EAAaG,QAAb,CAAjB,CATwB,CAWxB;;AACA/B,UAAAA,KAAK,CAACN,WAAN,CAAkBuC,IAAlB,CAAuBX,OAAvB;AACAtB,UAAAA,KAAK,CAACL,sBAAN,GAA+B,IAA/B;AACH;;AAED,iCACOK,KADP;AAGH;;AAED,SAAKf,KAAK,CAACiD,cAAX;AAA2B;AACvB,cAAMC,YAAY,GAAG3B,MAAM,CAACI,OAAP,CAAeuB,YAApC;;AAEA,YAAInC,KAAK,CAACN,WAAN,CAAkByC,YAAlB,CAAJ,EAAqC;AACjCnC,UAAAA,KAAK,CAACN,WAAN,CAAkByC,YAAlB,EAAgCH,MAAhC,CAAuCI,OAAvC,CAA+CC,GAAG,IAAI;AAClDA,YAAAA,GAAG,CAACnB,QAAJ,GAAe,KAAf;AACAmB,YAAAA,GAAG,CAAChB,WAAJ,GAAkB,IAAlB;AACAgB,YAAAA,GAAG,CAACf,OAAJ,GAAc,IAAd;AACH,WAJD;AAKAtB,UAAAA,KAAK,CAACN,WAAN,CAAkBU,MAAlB,CAAyB+B,YAAzB,EAAuC,CAAvC;AACH;;AAED,iCACOnC,KADP;AAGH;;AAED,SAAKf,KAAK,CAACqD,YAAX;AAAyB;AACrB,cAAMxC,OAAO,GAAGU,MAAM,CAACI,OAAP,CAAed,OAA/B;AAEAE,QAAAA,KAAK,CAACJ,QAAN,GAAiB,CAAjB;AACAI,QAAAA,KAAK,CAACF,OAAN,GAAgB,CAAC,GAAGA,OAAJ,EAAayC,IAAb,CAAkB,MAAMd,IAAI,CAACe,MAAL,KAAgBf,IAAI,CAACe,MAAL,EAAxC,CAAhB;AAEA,iCACOxC,KADP;AAGH;;AAED,SAAKf,KAAK,CAACwD,SAAX;AAAsB;AAClB,cAAMC,SAAS,GAAGlC,MAAM,CAACI,OAAP,CAAe8B,SAAjC;AAEA1C,QAAAA,KAAK,CAACH,mBAAN,CAA0BoC,IAA1B,CAA+BS,SAA/B;;AAEA,YAAI1C,KAAK,CAACH,mBAAN,CAA0BQ,MAA1B,KAAqCL,KAAK,CAACV,OAAN,CAAce,MAAvD,EAA+D;AAC3DL,UAAAA,KAAK,CAACJ,QAAN,GAAiB,CAAjB;AACH;;AAED,iCACOI,KADP;AAGH;;AAED,SAAKf,KAAK,CAAC0D,OAAX;AAAoB;AAChB,cAAMC,eAAe,GAAG5C,KAAK,CAACN,WAAN,CAAkBU,MAAlB,CAAyB,CAAzB,EAA4BJ,KAAK,CAACN,WAAN,CAAkBW,MAA9C,CAAxB;AAEAL,QAAAA,KAAK,CAACL,sBAAN,GAA+B,IAA/B;AACAK,QAAAA,KAAK,CAACJ,QAAN,GAAiB,CAAjB;AACAI,QAAAA,KAAK,CAACH,mBAAN,CAA0BO,MAA1B,CAAiC,CAAjC,EAAoCJ,KAAK,CAACH,mBAAN,CAA0BQ,MAA9D;AAEAuC,QAAAA,eAAe,CAACR,OAAhB,CAAwB9C,OAAO,IAAI;AAC/BA,UAAAA,OAAO,CAAC0C,MAAR,CAAeI,OAAf,CAAuBS,KAAK,IAAI;AAC5BA,YAAAA,KAAK,CAAC3B,QAAN,GAAiB,KAAjB;AACA2B,YAAAA,KAAK,CAACxB,WAAN,GAAoB,IAApB;AACH,WAHD;AAIH,SALD;AAOA,iCACOrB,KADP;AAGH;;AAED,SAAKf,KAAK,CAAC6D,KAAX;AAAkB;AACd9C,QAAAA,KAAK,CAACX,UAAN,GAAmB,KAAnB;AACAW,QAAAA,KAAK,CAACV,OAAN,CAAcc,MAAd,CAAqB,CAArB,EAAwBJ,KAAK,CAACV,OAAN,CAAce,MAAtC;AACAL,QAAAA,KAAK,CAACT,QAAN,GAAiB,CAAjB;AACAS,QAAAA,KAAK,CAACR,SAAN,GAAkBN,aAAa,CAACC,YAAhC;AACAa,QAAAA,KAAK,CAACP,cAAN,GAAuB,EAAvB;AACAO,QAAAA,KAAK,CAACN,WAAN,CAAkBU,MAAlB,CAAyB,CAAzB,EAA4BJ,KAAK,CAACN,WAAN,CAAkBW,MAA9C;AACAL,QAAAA,KAAK,CAACL,sBAAN,GAA+B,IAA/B;AACAK,QAAAA,KAAK,CAACJ,QAAN,GAAiB,CAAjB;AACAI,QAAAA,KAAK,CAACH,mBAAN,CAA0BO,MAA1B,CAAiC,CAAjC,EAAoCJ,KAAK,CAACH,mBAAN,CAA0BQ,MAA9D;AAEA,iCACOL,KADP;AAGH;;AAED;AAAS;AACL,eAAOA,KAAP;AACH;AApLL;AAsLH,CAvLM;AAyLP,eAAeO,iBAAf","sourcesContent":["import { State, MapData, MidLine } from '~/components/LadderGame.interface'\nimport * as types from '~/components/LadderGame.type'\n\nexport const defaultOption = {\n    mapMinHeight: 300,\n}\n\nexport const LadderGameInitialState: State = {\n    hasMapData: false,\n    mapData: [],\n    mapWidth: 0,\n    mapHeight: defaultOption.mapMinHeight,\n    ladderBlockCnt: 21,\n    midLineData: [],\n    generatingMidLinePoint: null,\n    gameStep: 0,\n    completedLineIndexs: [],\n    rewards: [],\n}\n\nexport const LadderGameInitializer = (state: State) => {\n    for (const key in state) {\n        Array.isArray(state[key]) && state[key].splice(0, state[key].length)\n    }\n    return state\n}\n\nlet __uid = 0\n\nexport const LadderGameReducer = (state: State, action: {type: string, payload?: any}) => {\n    switch (action.type) {\n        case types.CREATE_MAP_DATA: {\n            const ladderQty: number = action.payload.ladderQty\n\n\n            for (let x = 0; x < ladderQty; x++) {\n                state.mapData[x] = []\n                for (let y = 0; y < state.ladderBlockCnt; y++) {\n                    state.mapData[x][y] =  {\n                        uid: ++__uid,\n                        el: null,\n                        x,\n                        y,\n                        isHandle: false,\n                        isLinked: false,\n                        prevBlock: null,\n                        nextBlock: null,\n                        linkedBlock: null,\n                        midLine: null,\n                    }\n\n                    if (y > 0) {\n                        const prev = state.mapData[x][y - 1]\n                        prev.nextBlock = state.mapData[x][y]\n                        state.mapData[x][y].prevBlock = prev\n                    }\n\n                    if (y > 0 && y < state.ladderBlockCnt - 1) {\n                        state.mapData[x][y].isHandle = y % 2 !== 0\n                    }\n                }\n            }\n\n            if (Array.isArray(state.mapData)) {\n                state.mapData.splice(0, state.mapData.length, ...state.mapData)\n            }\n\n            return {\n                ...state,\n                hasMapData: state.mapData.length > 0,\n            }\n        }\n\n        case types.UPDATE_MAP_SIZE: {\n            const mapWidth = action.payload?.mapWidth ?? 0\n            const mapHeight = Math.max(state.mapHeight, action.payload?.mapHeight ?? 0)\n\n            return {\n                ...state,\n                mapWidth,\n                mapHeight,\n            }\n        }\n\n        case types.START_GENERATING_MIDLINE: {\n            const generatingMidLinePoint = action.payload.startPoint\n\n            return {\n                ...state,\n                generatingMidLinePoint,\n            }\n        }\n\n        case types.CANCEL_GENERATING_MIDLINE: {\n            return {\n                ...state,\n                generatingMidLinePoint: null,\n            }\n        }\n\n        case types.FINISH_GENERATING_MIDLINE: {\n            const startPoint: MapData | null = state.generatingMidLinePoint ?? null\n            const endPoint: MapData | null = action.payload.endPoint ?? null\n\n            const midLine: MidLine = {\n                uid: ++__uid,\n                el: null,\n                blocks: [],\n            }\n\n            if (startPoint && endPoint) {\n\n                // startPoint, endPoint 서로 연결\n                startPoint.isLinked = true\n                endPoint.isLinked = true\n                startPoint.linkedBlock = endPoint\n                endPoint.linkedBlock = startPoint\n                startPoint.midLine = midLine\n                endPoint.midLine = midLine\n                midLine.blocks = [startPoint, endPoint]\n\n                // state에 저장\n                state.midLineData.push(midLine)\n                state.generatingMidLinePoint = null\n            }\n\n            return {\n                ...state,\n            }\n        }\n\n        case types.REMOVE_MIDLINE: {\n            const midLineIndex = action.payload.midLineIndex\n\n            if (state.midLineData[midLineIndex]) {\n                state.midLineData[midLineIndex].blocks.forEach(row => {\n                    row.isLinked = false\n                    row.linkedBlock = null\n                    row.midLine = null\n                })\n                state.midLineData.splice(midLineIndex, 1)\n            }\n\n            return {\n                ...state,\n            }\n        }\n\n        case types.PREPARE_GAME: {\n            const rewards = action.payload.rewards\n\n            state.gameStep = 1\n            state.rewards = [...rewards].sort(() => Math.random() - Math.random())\n\n            return {\n                ...state,\n            }\n        }\n\n        case types.PLAY_GAME: {\n            const lineIndex = action.payload.lineIndex\n\n            state.completedLineIndexs.push(lineIndex)\n\n            if (state.completedLineIndexs.length === state.mapData.length) {\n                state.gameStep = 2\n            }\n\n            return {\n                ...state,\n            }\n        }\n\n        case types.RE_GAME: {\n            const prevMidLineData = state.midLineData.splice(0, state.midLineData.length)\n\n            state.generatingMidLinePoint = null\n            state.gameStep = 0\n            state.completedLineIndexs.splice(0, state.completedLineIndexs.length)\n\n            prevMidLineData.forEach(mapData => {\n                mapData.blocks.forEach(block => {\n                    block.isLinked = false\n                    block.linkedBlock = null\n                })\n            })\n\n            return {\n                ...state,\n            }\n        }\n\n        case types.RESET: {\n            state.hasMapData = false\n            state.mapData.splice(0, state.mapData.length)\n            state.mapWidth = 0\n            state.mapHeight = defaultOption.mapMinHeight\n            state.ladderBlockCnt = 21\n            state.midLineData.splice(0, state.midLineData.length)\n            state.generatingMidLinePoint = null\n            state.gameStep = 0\n            state.completedLineIndexs.splice(0, state.completedLineIndexs.length)\n\n            return {\n                ...state,\n            }\n        }\n\n        default: {\n            return state\n        }\n    }\n}\n\nexport default LadderGameReducer\n"]},"metadata":{},"sourceType":"module"}