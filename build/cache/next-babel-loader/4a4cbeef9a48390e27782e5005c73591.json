{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { colors } from '~/components/LadderGame.style';\n\nvar ResultCanvas = function ResultCanvas(props) {\n  var canvasRef = useRef(null);\n  var width = props.width,\n      height = props.height,\n      lineIndex = props.lineIndex,\n      map = props.map;\n\n  var _useState = useState(function () {\n    return {\n      coordinates: [],\n      lineWidth: 3,\n      animations: []\n    };\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  useEffect(function () {\n    calcCoordinates();\n  }, [width, height, lineIndex, map]);\n  useEffect(function () {\n    makeAnimations();\n  }, [state.coordinates]);\n  useEffect(function () {\n    drawCanvas(true);\n  }, [state.animations]);\n  var calcCoordinates = useCallback(function () {\n    var nextCoordinates = [];\n    var prevBlockUid = 0;\n    var current = map[lineIndex][0];\n\n    while (current !== null) {\n      var _current;\n\n      var next = null;\n\n      if (current.nextBlock) {\n        if (nextCoordinates.length === 0) {\n          var _current$el, _current$el2, _current$el3;\n\n          // 시작\n          nextCoordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - state.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n          next = current.nextBlock;\n        } else if (current.linkedBlock) {\n          if (current.isHandle) {\n            var _current$el4, _current$el5, _current$el6, _current$el7;\n\n            nextCoordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - state.lineWidth) / 2]);\n          }\n\n          if (current.linkedBlock.uid === prevBlockUid) {\n            // midLine 이동 후\n            next = current.nextBlock;\n          } else {\n            // midLine 이동 전\n            next = current.linkedBlock;\n          }\n        } else {\n          // 일반 block\n          next = current.nextBlock;\n        }\n      } else {\n        var _current$el8, _current$el9, _current$el10, _current$el11;\n\n        // 끝\n        nextCoordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n      }\n\n      prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n      current = next;\n    }\n\n    setState(function (prevState) {\n      return _objectSpread({}, prevState, {\n        coordinates: [].concat(nextCoordinates)\n      });\n    });\n  }, [lineIndex, map]);\n  var makeAnimations = useCallback(function () {\n    if (!canvasRef.current || !width || !height) return;\n    canvasRef.current.width = width;\n    canvasRef.current.height = height;\n    var canvas = canvasRef.current;\n    var ctx = canvas.getContext('2d');\n    var color = colors[lineIndex % colors.length];\n    if (!ctx) return;\n    var lastIndex = state.coordinates.length - 1;\n\n    var waypointMapper = function waypointMapper(waypoint) {\n      return function (isEnd) {\n        ctx.lineTo.apply(ctx, _toConsumableArray(waypoint));\n        isEnd && ctx.stroke();\n      };\n    };\n\n    ctx.lineWidth = state.lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    var animations = state.coordinates.reduce(function (result, currentCoordinate, index) {\n      var prevCoordinate = state.coordinates[index - 1];\n\n      if (index === 0) {\n        result.push(function () {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] - 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n          ctx.beginPath();\n        });\n        result = result.concat(calcWaypoints([currentCoordinate[0], currentCoordinate[1] - 3], currentCoordinate).map(waypointMapper));\n      }\n\n      if (prevCoordinate) {\n        result = result.concat(calcWaypoints(prevCoordinate, currentCoordinate).map(waypointMapper));\n      }\n\n      if (index === lastIndex) {\n        result = result.concat(calcWaypoints(currentCoordinate, [currentCoordinate[0], currentCoordinate[1] + 3]).map(waypointMapper));\n        result.push(function () {\n          ctx.stroke();\n          ctx.closePath();\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] + 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n        });\n      }\n\n      return result;\n    }, []);\n    setState(function (prevState) {\n      return _objectSpread({}, prevState, {\n        animations: _toConsumableArray(animations)\n      });\n    });\n  }, [state.lineWidth, state.coordinates, width, height, lineIndex]);\n  var calcWaypoints = useCallback(function (start, end) {\n    var waypoints = [];\n    var dx = end[0] - start[0];\n    var dy = end[1] - start[1];\n    var frames = Math.round(Math.sqrt(Math.pow(Math.abs(dx), 2) + Math.pow(Math.abs(dy), 2)) / 10);\n\n    for (var i = 0; i <= frames; i++) {\n      var x = start[0] + dx * i / frames;\n      var y = start[1] + dy * i / frames;\n      waypoints.push([x, y]);\n    }\n\n    return waypoints;\n  }, []);\n  var drawCanvas = useCallback(function () {\n    var useAnimation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var playIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    for (var index in state.animations) {\n      var _isEnd = playIndex <= index;\n\n      var animationCallback = state.animations[index];\n      animationCallback === null || animationCallback === void 0 ? void 0 : animationCallback(_isEnd);\n      if (_isEnd) break;\n    }\n\n    playIndex++;\n\n    if (useAnimation) {\n      requestAnimationFrame(function () {\n        return drawCanvas(useAnimation, playIndex);\n      });\n    } else {\n      drawCanvas(useAnimation, playIndex);\n    }\n  }, [state.animations]);\n  return __jsx(\"canvas\", {\n    ref: canvasRef,\n    width: width,\n    height: height\n  });\n};\n\nexport default ResultCanvas;","map":null,"metadata":{},"sourceType":"module"}