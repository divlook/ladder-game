{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { colors } from '~/components/LadderGame.style';\n\nconst ResultCanvas = props => {\n  const canvasRef = useRef(null);\n  const {\n    0: mounted,\n    1: setMount\n  } = useState(false);\n  const {\n    0: state,\n    1: setState\n  } = useState(() => {\n    return {\n      coordinates: [],\n      lineWidth: 3,\n      animations: []\n    };\n  });\n  useEffect(() => {\n    const {\n      stopAnimation\n    } = drawCanvas(true);\n    setMount(true);\n    return () => {\n      stopAnimation();\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted) {\n      drawCanvas();\n    }\n  }, [props]);\n  const drawCanvas = useCallback((isManual = false) => {\n    const coordinates = calcCoordinates();\n    const animations = makeAnimations(coordinates);\n    setState(prevState => _objectSpread({}, prevState, {\n      animations,\n      coordinates\n    }));\n    return playAnimation(animations, isManual);\n  }, []);\n  const calcCoordinates = useCallback(() => {\n    const coordinates = [];\n    let prevBlockUid = 0;\n    let current = props.map[props.lineIndex][0];\n\n    while (current !== null) {\n      var _current;\n\n      let next = null;\n\n      if (current.nextBlock) {\n        if (coordinates.length === 0) {\n          var _current$el, _current$el2, _current$el3;\n\n          // 시작\n          coordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - state.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n          next = current.nextBlock;\n        } else if (current.linkedBlock) {\n          if (current.isHandle) {\n            var _current$el4, _current$el5, _current$el6, _current$el7;\n\n            coordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - state.lineWidth) / 2]);\n          }\n\n          if (current.linkedBlock.uid === prevBlockUid) {\n            // midLine 이동 후\n            next = current.nextBlock;\n          } else {\n            // midLine 이동 전\n            next = current.linkedBlock;\n          }\n        } else {\n          // 일반 block\n          next = current.nextBlock;\n        }\n      } else {\n        var _current$el8, _current$el9, _current$el10, _current$el11;\n\n        // 끝\n        coordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n      }\n\n      prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n      current = next;\n    }\n\n    return coordinates;\n  }, [props.map, props.lineIndex, state.lineWidth]);\n  const makeAnimations = useCallback((coordinates = state.coordinates) => {\n    if (!canvasRef.current || !props.width || !props.height) return [];\n    canvasRef.current.width = props.width;\n    canvasRef.current.height = props.height;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const color = colors[props.lineIndex % colors.length];\n    if (!ctx) return [];\n    const lastIndex = coordinates.length - 1;\n\n    const waypointMapper = waypoint => isEnd => {\n      ctx.lineTo(...waypoint);\n      isEnd && ctx.stroke();\n    };\n\n    ctx.lineWidth = state.lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    const animations = coordinates.reduce((result, currentCoordinate, index) => {\n      const prevCoordinate = coordinates[index - 1];\n\n      if (index === 0) {\n        result.push(() => {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] - 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n          ctx.beginPath();\n        });\n        result = result.concat(calcWaypoints([currentCoordinate[0], currentCoordinate[1] - 3], currentCoordinate).map(waypointMapper));\n      }\n\n      if (prevCoordinate) {\n        result = result.concat(calcWaypoints(prevCoordinate, currentCoordinate).map(waypointMapper));\n      }\n\n      if (index === lastIndex) {\n        result = result.concat(calcWaypoints(currentCoordinate, [currentCoordinate[0], currentCoordinate[1] + 3]).map(waypointMapper));\n        result.push(() => {\n          ctx.stroke();\n          ctx.closePath();\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] + 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n        });\n      }\n\n      return result;\n    }, []);\n    return animations;\n  }, [props, state.coordinates, state.lineWidth]);\n  const calcWaypoints = useCallback((start, end) => {\n    const waypoints = [];\n    const dx = end[0] - start[0];\n    const dy = end[1] - start[1];\n    const frames = Math.round(Math.sqrt(Math.pow(Math.abs(dx), 2) + Math.pow(Math.abs(dy), 2)) / 10);\n\n    for (let i = 0; i <= frames; i++) {\n      const x = start[0] + dx * i / frames;\n      const y = start[1] + dy * i / frames;\n      waypoints.push([x, y]);\n    }\n\n    return waypoints;\n  }, []);\n  const playAnimation = useCallback((animations, useAnimation = false, playAnimationState = {\n    playing: true,\n    playIndex: 0\n  }) => {\n    for (const index in animations) {\n      const isEnd = useAnimation && playAnimationState.playIndex <= Number(index);\n      const animationCallback = animations[index];\n      animationCallback === null || animationCallback === void 0 ? void 0 : animationCallback(isEnd);\n      if (isEnd) break;\n    }\n\n    playAnimationState.playIndex++;\n\n    if (playAnimationState.playing && useAnimation && playAnimationState.playIndex < animations.length) {\n      requestAnimationFrame(() => playAnimation(animations, useAnimation, playAnimationState));\n    }\n\n    return {\n      stopAnimation() {\n        playAnimationState.playing = false;\n      }\n\n    };\n  }, []);\n  return __jsx(\"canvas\", {\n    ref: canvasRef,\n    width: props.width,\n    height: props.height\n  });\n};\n\nexport default ResultCanvas;","map":{"version":3,"sources":["/Users/chad/_workspace/ladder-game/components/ResultCanvas.tsx"],"names":["React","useRef","useEffect","useState","useCallback","colors","ResultCanvas","props","canvasRef","mounted","setMount","state","setState","coordinates","lineWidth","animations","stopAnimation","drawCanvas","isManual","calcCoordinates","makeAnimations","prevState","playAnimation","prevBlockUid","current","map","lineIndex","next","nextBlock","length","push","el","offsetLeft","offsetWidth","offsetTop","linkedBlock","isHandle","offsetHeight","uid","width","height","canvas","ctx","getContext","color","lastIndex","waypointMapper","waypoint","isEnd","lineTo","stroke","lineCap","lineJoin","strokeStyle","fillStyle","reduce","result","currentCoordinate","index","prevCoordinate","clearRect","beginPath","arc","Math","PI","closePath","fill","concat","calcWaypoints","start","end","waypoints","dx","dy","frames","round","sqrt","pow","abs","i","x","y","useAnimation","playAnimationState","playing","playIndex","Number","animationCallback","requestAnimationFrame"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react'\nimport { MapData } from '~/components/LadderGame.interface'\nimport { colors } from '~/components/LadderGame.style'\n\ninterface ResultCanvasProps {\n    lineIndex: number\n    width: number\n    height: number\n    map: MapData[][]\n}\n\ninterface ResultCanvasState {\n    coordinates: Waypoint[]\n    lineWidth: number\n    animations: AnimationCallback[]\n}\n\ntype Waypoint = [number, number]\ntype AnimationCallback = (isEnd: boolean) => void\n\nconst ResultCanvas: React.FC<ResultCanvasProps> = props => {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n    const [mounted, setMount] = useState(false)\n    const [state, setState] = useState<ResultCanvasState>(() => {\n        return {\n            coordinates: [],\n            lineWidth: 3,\n            animations: [],\n        }\n    })\n\n    useEffect(() => {\n        const { stopAnimation } = drawCanvas(true)\n        setMount(true)\n\n        return () => {\n            stopAnimation()\n        }\n    }, [])\n\n    useEffect(() => {\n        if (mounted) {\n            drawCanvas()\n        }\n    }, [props])\n\n    const drawCanvas = useCallback((isManual = false) => {\n        const coordinates = calcCoordinates()\n        const animations = makeAnimations(coordinates)\n\n        setState(prevState => ({\n            ...prevState,\n            animations,\n            coordinates,\n        }))\n\n        return playAnimation(animations, isManual)\n    }, [])\n\n    const calcCoordinates = useCallback(() => {\n        const coordinates: Waypoint[] = []\n        let prevBlockUid = 0\n        let current: MapData | null = props.map[props.lineIndex][0]\n\n        while (current !== null) {\n            let next: MapData | null = null\n            if (current.nextBlock) {\n                if (coordinates.length === 0) {\n                    // 시작\n                    coordinates.push([\n                        (current.el?.offsetLeft || 0) + (current.el?.offsetWidth || 0 - state.lineWidth) / 2,\n                        current.el?.offsetTop || 0,\n                    ])\n\n                    next = current.nextBlock\n                } else if (current.linkedBlock) {\n                    if (current.isHandle) {\n                        coordinates.push([\n                            (current.el?.offsetLeft || 0) + (current.el?.offsetWidth || 0 - state.lineWidth) / 2,\n                            (current.el?.offsetTop || 0) + (current.el?.offsetHeight || 0 - state.lineWidth) / 2,\n                        ])\n                    }\n\n                    if (current.linkedBlock.uid === prevBlockUid) {\n                        // midLine 이동 후\n                        next = current.nextBlock\n                    } else {\n                        // midLine 이동 전\n                        next = current.linkedBlock\n                    }\n                } else {\n                    // 일반 block\n                    next = current.nextBlock\n                }\n            } else {\n                // 끝\n                coordinates.push([\n                    (current.el?.offsetLeft || 0) + (current.el?.offsetWidth || 0 - state.lineWidth) / 2,\n                    (current.el?.offsetTop || 0) + (current.el?.offsetHeight || 0),\n                ])\n            }\n\n            prevBlockUid = current?.uid || 0\n            current = next\n        }\n\n        return coordinates\n    }, [props.map, props.lineIndex, state.lineWidth])\n\n    const makeAnimations = useCallback(\n        (coordinates = state.coordinates) => {\n            if (!canvasRef.current || !props.width || !props.height) return []\n\n            canvasRef.current.width = props.width\n            canvasRef.current.height = props.height\n\n            const canvas = canvasRef.current\n            const ctx = canvas.getContext('2d')\n            const color = colors[props.lineIndex % colors.length]\n\n            if (!ctx) return []\n\n            const lastIndex = coordinates.length - 1\n            const waypointMapper = (waypoint: Waypoint) => isEnd => {\n                ctx.lineTo(...waypoint)\n                isEnd && ctx.stroke()\n            }\n\n            ctx.lineWidth = state.lineWidth\n            ctx.lineCap = 'round'\n            ctx.lineJoin = 'round'\n            ctx.strokeStyle = color\n            ctx.fillStyle = color\n\n            const animations = coordinates.reduce((result: AnimationCallback[], currentCoordinate, index) => {\n                const prevCoordinate = coordinates[index - 1]\n\n                if (index === 0) {\n                    result.push(() => {\n                        ctx.clearRect(0, 0, canvas.width, canvas.height)\n                        ctx.beginPath()\n                        ctx.arc(currentCoordinate[0], currentCoordinate[1] - 8, 6, 0, Math.PI * 2)\n                        ctx.closePath()\n                        ctx.fill()\n                        ctx.beginPath()\n                    })\n\n                    result = result.concat(\n                        calcWaypoints([currentCoordinate[0], currentCoordinate[1] - 3], currentCoordinate).map(waypointMapper)\n                    )\n                }\n\n                if (prevCoordinate) {\n                    result = result.concat(calcWaypoints(prevCoordinate, currentCoordinate).map(waypointMapper))\n                }\n\n                if (index === lastIndex) {\n                    result = result.concat(\n                        calcWaypoints(currentCoordinate, [currentCoordinate[0], currentCoordinate[1] + 3]).map(waypointMapper)\n                    )\n                    result.push(() => {\n                        ctx.stroke()\n                        ctx.closePath()\n                        ctx.beginPath()\n                        ctx.arc(currentCoordinate[0], currentCoordinate[1] + 8, 6, 0, Math.PI * 2)\n                        ctx.closePath()\n                        ctx.fill()\n                    })\n                }\n\n                return result\n            }, [])\n\n            return animations\n        },\n        [props, state.coordinates, state.lineWidth]\n    )\n\n    const calcWaypoints = useCallback((start: number[], end: number[]) => {\n        const waypoints: Waypoint[] = []\n        const dx = end[0] - start[0]\n        const dy = end[1] - start[1]\n        const frames = Math.round(Math.sqrt(Math.pow(Math.abs(dx), 2) + Math.pow(Math.abs(dy), 2)) / 10)\n\n        for (let i = 0; i <= frames; i++) {\n            const x = start[0] + (dx * i) / frames\n            const y = start[1] + (dy * i) / frames\n\n            waypoints.push([x, y])\n        }\n\n        return waypoints\n    }, [])\n\n    const playAnimation = useCallback(\n        (animations: AnimationCallback[], useAnimation = false, playAnimationState = { playing: true, playIndex: 0 }) => {\n            for (const index in animations) {\n                const isEnd = useAnimation && playAnimationState.playIndex <= Number(index)\n                const animationCallback = animations[index]\n                animationCallback?.(isEnd)\n                if (isEnd) break\n            }\n\n            playAnimationState.playIndex++\n\n            if (playAnimationState.playing && useAnimation && playAnimationState.playIndex < animations.length) {\n                requestAnimationFrame(() => playAnimation(animations, useAnimation, playAnimationState))\n            }\n\n            return {\n                stopAnimation() {\n                    playAnimationState.playing = false\n                },\n            }\n        },\n        []\n    )\n\n    return <canvas ref={canvasRef} width={props.width} height={props.height} />\n}\n\nexport default ResultCanvas\n"]},"metadata":{},"sourceType":"module"}