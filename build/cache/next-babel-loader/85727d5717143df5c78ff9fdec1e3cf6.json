{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { Typography, Box, Grid, Button } from '@material-ui/core';\nimport { useLifecycle } from '~/hooks/Lifecycle';\nimport { colors, useStyles } from '~/components/LadderGame.style';\n/*\nTODO:\n\n// 클릭=터치\n// block은 1:1로만 연결가능\n// block이 1:1로 연결되면 midLine이 생성됨.\n// midLine은 [prevStep ,nextStep] 데이터를 가지고 있어야됨. 좌표를 저장하는 방법은 2가지가 있음\n// - 1. useMemo를 사용하여 mapData가 변경될 때마다 새로 계산하는 방법\n// - 2. new Map()을 사용하여 변경할때마다 해당 hash만 변경하는 방법\n// 연결되면 isLinked가 true가 되고 더이상 클릭할 수 없음.\n// midLine을 취소할 수 있으며, 취소하면 원상복귀시켜야 됨.\n// 보상은 midLine이 다 그려진 뒤 게임이 시작되기전에 순서를 랜덤으로 섞어야됨\n// resultLine은 mapData의 0부터 시작해서 nextStep을 따라 그려져야됨\nresultLine이 그려질 때 애니메이션 추가\n결과 데이터 저장\n확률 표시\n\n싱글모드, 멀티모드\n유저정보 입력\n호스트가 게임 생성\n다른 유저들이 게임에 참가\n\nFIXME:\nuseReducer로 변경하고 파일 분리\nmethods는 useCallback 또는 action으로 분리\n*/\n\nexport var defaultOption = {\n  mapMinHeight: 300\n};\nexport var initialState = {\n  isPaintingLadder: false,\n  isPaintedLadder: false,\n  mapData: [],\n  mapWidth: 0,\n  mapHeight: defaultOption.mapMinHeight,\n  ladderBlockCnt: 21,\n  midLineData: [],\n  generatingMidLinePoint: null,\n  gameStep: 0,\n  completedLineIndexs: [],\n  colorIndex: 0,\n  rewards: []\n};\nvar __uid = 0;\n\nvar LadderGame = function LadderGame(props) {\n  var _useLifecycle = useLifecycle({\n    useLog: true,\n    logLabel: 'LadderGame'\n  }),\n      useCreated = _useLifecycle.useCreated,\n      useMounted = _useLifecycle.useMounted,\n      useBeforeDestroy = _useLifecycle.useBeforeDestroy;\n\n  var _useState = useState(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var classes = useStyles(state)();\n  var mapRef = useRef(null);\n  var resultRef = useRef(null);\n  var methods = {\n    calcMapSize: function calcMapSize() {\n      if (mapRef.current) {\n        var _mapRef$current, _mapRef$current2;\n\n        state.mapWidth = ((_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.scrollWidth) || 0;\n        state.mapHeight = Math.max(state.mapHeight, ((_mapRef$current2 = mapRef.current) === null || _mapRef$current2 === void 0 ? void 0 : _mapRef$current2.scrollHeight) || 0);\n        setState(state);\n        return true;\n      } else {\n        return false;\n      }\n    },\n    paintLadder: function paintLadder() {\n      var ladderQty = props.ladderQty;\n      var mapData = state.mapData;\n      state.isPaintingLadder = true;\n\n      for (var x = 0; x < ladderQty; x++) {\n        mapData[x] = [];\n\n        for (var y = 0; y < state.ladderBlockCnt; y++) {\n          mapData[x][y] = methods.createMapData(x, y);\n\n          if (y > 0) {\n            var prev = mapData[x][y - 1];\n            prev.nextBlock = mapData[x][y];\n            mapData[x][y].prevBlock = prev;\n          }\n\n          if (y > 0 && y < state.ladderBlockCnt - 1) {\n            mapData[x][y].isHandle = y % 2 !== 0;\n          }\n        }\n      }\n\n      state.mapData = mapData;\n      state.isPaintingLadder = false;\n      state.isPaintedLadder = true;\n      setState(state);\n    },\n    calcMidLineStyle: function calcMidLineStyle(startPoint, endPoint) {\n      var _startPoint$el, _endPoint$el, _startPoint$el2, _endPoint$el2, _startPoint$el3, _endPoint$el3;\n\n      var toTheSameTop = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el = startPoint.el) === null || _startPoint$el === void 0 ? void 0 : _startPoint$el.offsetTop) || 0) === ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el = endPoint.el) === null || _endPoint$el === void 0 ? void 0 : _endPoint$el.offsetTop) || 0);\n      var toTheBottom = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el2 = startPoint.el) === null || _startPoint$el2 === void 0 ? void 0 : _startPoint$el2.offsetTop) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el2 = endPoint.el) === null || _endPoint$el2 === void 0 ? void 0 : _endPoint$el2.offsetTop) || 0);\n      var toTheRight = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el3 = startPoint.el) === null || _startPoint$el3 === void 0 ? void 0 : _startPoint$el3.offsetLeft) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el3 = endPoint.el) === null || _endPoint$el3 === void 0 ? void 0 : _endPoint$el3.offsetLeft) || 0);\n      var leftPoint = toTheRight ? startPoint : endPoint;\n      var rightPoint = toTheRight ? endPoint : startPoint;\n\n      if ((leftPoint === null || leftPoint === void 0 ? void 0 : leftPoint.el) !== null && (rightPoint === null || rightPoint === void 0 ? void 0 : rightPoint.el) !== null) {\n        var defaultMidLineOption = {\n          width: 8\n        };\n        var style = {\n          display: 'block',\n          top: 0,\n          left: 0,\n          width: defaultMidLineOption.width,\n          height: defaultMidLineOption.width,\n          transform: 'rotate(0deg)'\n        };\n\n        if (toTheSameTop) {\n          var margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n          var addLine = leftPoint.el.offsetWidth - margin * 2;\n          style.width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine;\n          style.left = leftPoint.el.offsetLeft + margin;\n          style.top = leftPoint.el.offsetTop + margin;\n        } else {\n          var _margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n\n          var _addLine = leftPoint.el.offsetWidth - _margin * 2;\n\n          var width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + _addLine;\n\n          var height = Math.abs(leftPoint.el.offsetTop - rightPoint.el.offsetTop) + _addLine;\n\n          var angle = Math.atan(height / width) * 180 / Math.PI;\n          style.width = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n          style.left = leftPoint.el.offsetLeft - (style.width - width) / 2;\n          style.top = leftPoint.el.offsetTop + height / 2;\n          style.transform = \"rotate(\".concat(angle, \"deg)\"); // 방향에 따라 추가 연산\n\n          if (!toTheBottom && toTheRight || !toTheRight && toTheBottom) {\n            style.top += height * -1;\n            style.transform = \"rotate(\".concat(angle * -1, \"deg)\");\n          }\n\n          if (toTheBottom && toTheRight || !toTheBottom && !toTheRight) {\n            style.top -= defaultMidLineOption.width / 2;\n          }\n\n          if (!toTheBottom && toTheRight || toTheBottom && !toTheRight) {\n            style.top += defaultMidLineOption.width / 2;\n          } // margin 추가\n\n\n          style.left += _margin;\n          style.top += _margin;\n        }\n\n        return style;\n      }\n\n      return undefined;\n    },\n    connectMidLine: function connectMidLine(x, y) {\n      return function (e) {\n        var _state$generatingMidL;\n\n        e.persist();\n        console.group('item');\n        console.log('x', x, 'y', y);\n        console.log(state.mapData[x][y]);\n        console.groupEnd(); // handle만 조작 가능하다\n\n        if (!state.mapData[x][y].isHandle) return; // 이미 연결된건 조작 불가능하다\n\n        if (state.mapData[x][y].isLinked) return; // 같은 block을 클릭하면 취소된다\n\n        if (state.mapData[x][y] === state.generatingMidLinePoint) {\n          setState(_objectSpread({}, state, {\n            generatingMidLinePoint: null\n          }));\n          return;\n        } // 같은 라인의 block을 클릭하면 취소된다\n\n\n        if (x === ((_state$generatingMidL = state.generatingMidLinePoint) === null || _state$generatingMidL === void 0 ? void 0 : _state$generatingMidL.x)) {\n          setState(_objectSpread({}, state, {\n            generatingMidLinePoint: null\n          }));\n          return;\n        } // midLine 시작점을 저장한다\n\n\n        if (!state.generatingMidLinePoint) {\n          setState(_objectSpread({}, state, {\n            generatingMidLinePoint: state.mapData[x][y]\n          }));\n          return;\n        } // midLine을 그린다\n\n\n        if (state.generatingMidLinePoint) {\n          var midLine = {\n            uid: ++__uid,\n            el: null,\n            blocks: [],\n            style: undefined\n          };\n          var startPoint = state.generatingMidLinePoint;\n          var endPoint = state.mapData[x][y]; // startPoint, endPoint 서로 연결\n\n          startPoint.isLinked = true;\n          endPoint.isLinked = true;\n          startPoint.linkedBlock = endPoint;\n          endPoint.linkedBlock = startPoint;\n          startPoint.midLine = midLine;\n          endPoint.midLine = midLine;\n          midLine.blocks = [startPoint, endPoint];\n          midLine.style = methods.calcMidLineStyle(startPoint, endPoint); // state에 저장\n\n          state.midLineData.push(midLine);\n        } // 수정사항 반영 및 generatingMidLinePoint 초기화\n\n\n        setState(_objectSpread({}, state, {\n          generatingMidLinePoint: null\n        }));\n      };\n    },\n    cutMidLine: function cutMidLine(midLine) {\n      return function () {\n        midLine.blocks.forEach(function (row) {\n          row.isLinked = false;\n          row.linkedBlock = null;\n          row.midLine = null;\n        });\n        var midLineIndex = state.midLineData.findIndex(function (row) {\n          return row.uid === midLine.uid;\n        });\n        state.midLineData.splice(midLineIndex, 1);\n        setState(_objectSpread({}, state));\n      };\n    },\n    bindEl: function bindEl(data) {\n      return function (el) {\n        data.el = el;\n      };\n    },\n    createMapData: function createMapData(x, y) {\n      return {\n        uid: ++__uid,\n        el: null,\n        x: x,\n        y: y,\n        isHandle: false,\n        isLinked: false,\n        prevBlock: null,\n        nextBlock: null,\n        linkedBlock: null,\n        midLine: null\n      };\n    },\n    playGame: function playGame(key) {\n      return function () {\n        if (resultRef.current && !state.completedLineIndexs.includes(key)) {\n          var canvas = document.createElement('canvas');\n          var ctx = canvas.getContext('2d');\n          canvas.width = state.mapWidth;\n          canvas.height = state.mapHeight;\n\n          if (ctx) {\n            var coordinates = [];\n            var color = colors[state.colorIndex % colors.length];\n            var prevBlockUid = 0;\n            var current = state.mapData[key][0];\n            ctx.lineWidth = 3;\n            ctx.lineJoin = 'round';\n            ctx.strokeStyle = color;\n            ctx.fillStyle = color;\n\n            while (current !== null) {\n              var _current;\n\n              var next = null;\n\n              if (current.nextBlock) {\n                if (coordinates.length === 0) {\n                  var _current$el, _current$el2, _current$el3;\n\n                  // 시작\n                  coordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - ctx.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n                  next = current.nextBlock;\n                } else if (current.linkedBlock) {\n                  if (current.isHandle) {\n                    var _current$el4, _current$el5, _current$el6, _current$el7;\n\n                    coordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - ctx.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - ctx.lineWidth) / 2]);\n                  }\n\n                  if (current.linkedBlock.uid === prevBlockUid) {\n                    // midLine 이동 후\n                    next = current.nextBlock;\n                  } else {\n                    // midLine 이동 전\n                    next = current.linkedBlock;\n                  }\n                } else {\n                  // 일반 block\n                  next = current.nextBlock;\n                }\n              } else {\n                var _current$el8, _current$el9, _current$el10, _current$el11;\n\n                // 끝\n                coordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - ctx.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n              }\n\n              prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n              current = next;\n            }\n\n            for (var index = 0, len = coordinates.length; index < len; index++) {\n              var xy = coordinates[index];\n\n              if (index === 0) {\n                ctx.beginPath();\n                ctx.arc(xy[0], xy[1] - 8, 6, 0, Math.PI * 2);\n                ctx.closePath();\n                ctx.fill();\n                ctx.beginPath();\n                ctx.moveTo(xy[0], xy[1] - 3);\n                ctx.lineTo.apply(ctx, _toConsumableArray(xy));\n              } else {\n                ctx.lineTo.apply(ctx, _toConsumableArray(xy));\n              }\n\n              if (index === len - 1) {\n                ctx.lineTo(xy[0], xy[1] + 3);\n                ctx.stroke();\n                ctx.beginPath();\n                ctx.arc(xy[0], xy[1] + 8, 6, 0, Math.PI * 2);\n                ctx.closePath();\n                ctx.fill();\n              }\n            }\n\n            resultRef.current.append(canvas);\n          }\n\n          state.colorIndex++;\n          state.completedLineIndexs.push(key);\n\n          if (state.completedLineIndexs.length === state.mapData.length) {\n            state.gameStep = 2;\n          }\n\n          setState(_objectSpread({}, state, {\n            gameStep: state.gameStep,\n            completedLineIndexs: state.completedLineIndexs\n          }));\n          return true;\n        } else {\n          return false;\n        }\n      };\n    },\n    doReady: function doReady() {\n      state.gameStep = 1;\n      state.rewards = _toConsumableArray(props.rewards);\n      state.rewards.sort(function () {\n        return Math.random() - Math.random();\n      });\n      setState(_objectSpread({}, state));\n    },\n    reGame: function reGame() {\n      var prevMidLineData = state.midLineData.splice(0, state.midLineData.length);\n      state.generatingMidLinePoint = null;\n      state.gameStep = 0;\n      state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n      state.colorIndex = 0;\n      prevMidLineData.forEach(function (mapData) {\n        mapData.blocks.forEach(function (block) {\n          block.isLinked = false;\n          block.linkedBlock = null;\n        });\n      });\n\n      if (resultRef.current) {\n        while (resultRef.current.firstChild) {\n          resultRef.current.removeChild(resultRef.current.firstChild);\n        }\n      }\n\n      setState(_objectSpread({}, state));\n    },\n    handleOrientationchange: function handleOrientationchange() {\n      if (methods.calcMapSize()) {\n        // TODO: 회전시 midLine의 위치와 canvas가 갱신은 되나 게임이 처음부터 다시 시작되는 버그가 생김\n        setState(function (prevState) {\n          return _objectSpread({}, prevState, {\n            midLineData: state.midLineData.map(function (midLine) {\n              midLine.style = methods.calcMidLineStyle(midLine.blocks[0], midLine.blocks[1]);\n              return midLine;\n            })\n          });\n        });\n      }\n    }\n  };\n  useCreated(function _callee() {\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            methods.paintLadder();\n            window.addEventListener('orientationchange', methods.handleOrientationchange); // window.addEventListener('resize', () => { console.log('resize') })\n\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    });\n  });\n  useMounted(function () {\n    methods.calcMapSize();\n    console.log(state);\n  });\n  useBeforeDestroy(function () {\n    window.removeEventListener('orientationchange', methods.handleOrientationchange);\n    state.isPaintingLadder = false;\n    state.isPaintedLadder = false;\n    state.mapData.splice(0, state.mapData.length);\n    state.mapWidth = 0;\n    state.mapHeight = defaultOption.mapMinHeight;\n    state.ladderBlockCnt = 21;\n    state.midLineData.splice(0, state.midLineData.length);\n    state.generatingMidLinePoint = null;\n    state.gameStep = 0;\n    state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n    state.colorIndex = 0;\n  });\n  return __jsx(\"div\", {\n    className: classes.root\n  }, function () {\n    if (state.isPaintingLadder) {\n      return __jsx(Typography, null, \"\\uC0AC\\uB2E4\\uB9AC\\uAC00 \\uADF8\\uB824\\uC9C0\\uB294 \\uC911 \\uC785\\uB2C8\\uB2E4. \\uAE30\\uB2E4\\uB824\\uC8FC\\uC138\\uC694.\");\n    } else if (state.isPaintedLadder && !state.isPaintingLadder) {\n      return __jsx(React.Fragment, null, __jsx(\"div\", {\n        className: classes.ladders\n      }, __jsx(Grid, {\n        ref: mapRef,\n        className: classes.ladderContainer,\n        container: true,\n        spacing: 2\n      }, state.mapData.map(function (xVal, xIndex) {\n        return __jsx(Grid, {\n          key: xIndex,\n          item: true\n        }, __jsx(Box, {\n          className: classes.ladderItemHeader\n        }, __jsx(Button, {\n          className: classes.buttonItem,\n          variant: \"contained\",\n          color: \"primary\",\n          onClick: methods.playGame(xIndex),\n          disabled: state.gameStep === 0 || state.completedLineIndexs.includes(xIndex)\n        }, props.players[xIndex] || \"\\uCC38\\uAC00\\uC790 \".concat(xIndex + 1))), __jsx(Box, {\n          className: classes.ladderItem\n        }, xVal.map(function (yVal, yIndex) {\n          var _clsx;\n\n          return __jsx(\"div\", {\n            key: yIndex,\n            ref: methods.bindEl(yVal),\n            className: clsx(classes.ladderItemBlock, (_clsx = {}, _defineProperty(_clsx, classes.ladderItemHandle, yVal.isHandle), _defineProperty(_clsx, \"active\", state.generatingMidLinePoint === yVal), _defineProperty(_clsx, \"linked\", yVal.isLinked), _clsx)),\n            onClick: methods.connectMidLine(xIndex, yIndex)\n          });\n        })), __jsx(Box, {\n          className: classes.ladderItemFooter\n        }, state.gameStep === 0 && __jsx(Typography, null, \"\\uBCF4\\uC0C1 \", xIndex + 1), state.gameStep > 0 && __jsx(Typography, null, state.rewards[xIndex] || \"\\uBCF4\\uC0C1 \".concat(xIndex + 1))));\n      }), state.midLineData.map(function (midLine, midLineIndex) {\n        return __jsx(\"div\", {\n          key: midLineIndex,\n          ref: methods.bindEl(midLine),\n          className: classes.ladderMidLine,\n          style: midLine.style,\n          onClick: methods.cutMidLine(midLine)\n        });\n      }), __jsx(\"div\", {\n        ref: resultRef,\n        className: clsx(classes.result, {\n          active: state.gameStep > 0\n        })\n      }))), __jsx(Grid, {\n        container: true,\n        spacing: 2,\n        className: classes.buttons,\n        justify: \"center\"\n      }, __jsx(Grid, {\n        item: true\n      }, state.gameStep === 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.doReady\n      }, \"\\uC900\\uBE44 \\uC644\\uB8CC\"), state.gameStep > 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.reGame\n      }, \"\\uB2E4\\uC2DC\\uD558\\uAE30\"))));\n    } else {\n      return null;\n    }\n  }());\n};\n\nexport default LadderGame;","map":null,"metadata":{},"sourceType":"module"}