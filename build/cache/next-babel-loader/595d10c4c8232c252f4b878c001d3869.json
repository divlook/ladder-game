{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { colors } from '~/components/LadderGame.style';\n\nvar ResultCanvas = function ResultCanvas(props) {\n  var canvasRef = useRef(null);\n\n  var _useState = useState(false),\n      mounted = _useState[0],\n      setMount = _useState[1];\n\n  var _useState2 = useState(function () {\n    return {\n      coordinates: [],\n      lineWidth: 3,\n      animations: []\n    };\n  }),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  useEffect(function () {\n    var _drawCanvas = drawCanvas(true),\n        stopAnimation = _drawCanvas.stopAnimation;\n\n    setMount(true);\n    return function () {\n      stopAnimation();\n    };\n  }, []);\n  useEffect(function () {\n    if (mounted) {\n      drawCanvas();\n    }\n  }, [props]);\n  var drawCanvas = useCallback(function () {\n    var isManual = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var coordinates = calcCoordinates();\n    var animations = makeAnimations(coordinates);\n    setState(function (prevState) {\n      return _objectSpread({}, prevState, {\n        animations: animations,\n        coordinates: coordinates\n      });\n    });\n    return playAnimation(animations, isManual);\n  }, []);\n  var calcCoordinates = useCallback(function () {\n    var coordinates = [];\n    var prevBlockUid = 0;\n    var current = props.map[props.lineIndex][0];\n\n    while (current !== null) {\n      var _current;\n\n      var next = null;\n\n      if (current.nextBlock) {\n        if (coordinates.length === 0) {\n          var _current$el, _current$el2, _current$el3;\n\n          // 시작\n          coordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - state.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n          next = current.nextBlock;\n        } else if (current.linkedBlock) {\n          if (current.isHandle) {\n            var _current$el4, _current$el5, _current$el6, _current$el7;\n\n            coordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - state.lineWidth) / 2]);\n          }\n\n          if (current.linkedBlock.uid === prevBlockUid) {\n            // midLine 이동 후\n            next = current.nextBlock;\n          } else {\n            // midLine 이동 전\n            next = current.linkedBlock;\n          }\n        } else {\n          // 일반 block\n          next = current.nextBlock;\n        }\n      } else {\n        var _current$el8, _current$el9, _current$el10, _current$el11;\n\n        // 끝\n        coordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n      }\n\n      prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n      current = next;\n    }\n\n    return coordinates;\n  }, [props.map, props.lineIndex, state.lineWidth]);\n  var makeAnimations = useCallback(function () {\n    var coordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : state.coordinates;\n    if (!canvasRef.current || !props.width || !props.height) return [];\n    canvasRef.current.width = props.width;\n    canvasRef.current.height = props.height;\n    var canvas = canvasRef.current;\n    var ctx = canvas.getContext('2d');\n    var color = colors[props.lineIndex % colors.length];\n    if (!ctx) return [];\n    var lastIndex = coordinates.length - 1;\n\n    var waypointMapper = function waypointMapper(waypoint) {\n      return function (isEnd) {\n        ctx.lineTo.apply(ctx, _toConsumableArray(waypoint));\n        isEnd && ctx.stroke();\n      };\n    };\n\n    ctx.lineWidth = state.lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    var animations = coordinates.reduce(function (result, currentCoordinate, index) {\n      var prevCoordinate = coordinates[index - 1];\n\n      if (index === 0) {\n        result.push(function () {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] - 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n          ctx.beginPath();\n        });\n        result = result.concat(calcWaypoints([currentCoordinate[0], currentCoordinate[1] - 3], currentCoordinate).map(waypointMapper));\n      }\n\n      if (prevCoordinate) {\n        result = result.concat(calcWaypoints(prevCoordinate, currentCoordinate).map(waypointMapper));\n      }\n\n      if (index === lastIndex) {\n        result = result.concat(calcWaypoints(currentCoordinate, [currentCoordinate[0], currentCoordinate[1] + 3]).map(waypointMapper));\n        result.push(function () {\n          ctx.stroke();\n          ctx.closePath();\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] + 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n        });\n      }\n\n      return result;\n    }, []);\n    return animations;\n  }, [props, state.coordinates, state.lineWidth]);\n  var calcWaypoints = useCallback(function (start, end) {\n    var waypoints = [];\n    var dx = end[0] - start[0];\n    var dy = end[1] - start[1];\n    var frames = Math.round(Math.sqrt(Math.pow(Math.abs(dx), 2) + Math.pow(Math.abs(dy), 2)) / 10);\n\n    for (var i = 0; i <= frames; i++) {\n      var x = start[0] + dx * i / frames;\n      var y = start[1] + dy * i / frames;\n      waypoints.push([x, y]);\n    }\n\n    return waypoints;\n  }, []);\n  var playAnimation = useCallback(function (animations) {\n    var useAnimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var playAnimationState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      playing: true,\n      playIndex: 0\n    };\n\n    for (var index in animations) {\n      var _isEnd = useAnimation && playAnimationState.playIndex <= Number(index);\n\n      var animationCallback = animations[index];\n      animationCallback === null || animationCallback === void 0 ? void 0 : animationCallback(_isEnd);\n      if (_isEnd) break;\n    }\n\n    playAnimationState.playIndex++;\n\n    if (playAnimationState.playing && useAnimation && playAnimationState.playIndex < animations.length) {\n      requestAnimationFrame(function () {\n        return playAnimation(animations, useAnimation, playAnimationState);\n      });\n    }\n\n    return {\n      stopAnimation: function stopAnimation() {\n        playAnimationState.playing = false;\n      }\n    };\n  }, []);\n  return __jsx(\"canvas\", {\n    ref: canvasRef,\n    width: props.width,\n    height: props.height\n  });\n};\n\nexport default ResultCanvas;","map":null,"metadata":{},"sourceType":"module"}