{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { colors } from '~/components/LadderGame.style';\n\nconst ResultCanvas = props => {\n  const canvasRef = useRef(null);\n  const {\n    0: mounted,\n    1: setMount\n  } = useState(false);\n  const {\n    0: state,\n    1: setState\n  } = useState(() => {\n    return {\n      coordinates: [],\n      lineWidth: 3,\n      animations: []\n    };\n  });\n  useEffect(() => {\n    const {\n      stopAnimation\n    } = drawCanvas(true);\n    setMount(true);\n    return () => {\n      stopAnimation();\n    };\n  }, []);\n  useEffect(() => {\n    if (mounted) {\n      drawCanvas();\n    }\n  }, [props]);\n  const drawCanvas = useCallback((isManual = false) => {\n    const coordinates = calcCoordinates();\n    const animations = makeAnimations(coordinates);\n    setState(prevState => _objectSpread({}, prevState, {\n      animations,\n      coordinates\n    }));\n    return playAnimation(animations, isManual);\n  }, []);\n  const calcCoordinates = useCallback(() => {\n    const coordinates = [];\n    let prevBlockUid = 0;\n    let current = props.map[props.lineIndex][0];\n\n    while (current !== null) {\n      var _current;\n\n      let next = null;\n\n      if (current.nextBlock) {\n        if (coordinates.length === 0) {\n          var _current$el, _current$el2, _current$el3;\n\n          // 시작\n          coordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - state.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n          next = current.nextBlock;\n        } else if (current.linkedBlock) {\n          if (current.isHandle) {\n            var _current$el4, _current$el5, _current$el6, _current$el7;\n\n            coordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - state.lineWidth) / 2]);\n          }\n\n          if (current.linkedBlock.uid === prevBlockUid) {\n            // midLine 이동 후\n            next = current.nextBlock;\n          } else {\n            // midLine 이동 전\n            next = current.linkedBlock;\n          }\n        } else {\n          // 일반 block\n          next = current.nextBlock;\n        }\n      } else {\n        var _current$el8, _current$el9, _current$el10, _current$el11;\n\n        // 끝\n        coordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n      }\n\n      prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n      current = next;\n    }\n\n    return coordinates;\n  }, [props.map, props.lineIndex, state.lineWidth]);\n  const makeAnimations = useCallback((coordinates = state.coordinates) => {\n    if (!canvasRef.current || !props.width || !props.height) return [];\n    canvasRef.current.width = props.width;\n    canvasRef.current.height = props.height;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const color = colors[props.lineIndex % colors.length];\n    if (!ctx) return [];\n    const lastIndex = coordinates.length - 1;\n\n    const waypointMapper = waypoint => isEnd => {\n      ctx.lineTo(...waypoint);\n      isEnd && ctx.stroke();\n    };\n\n    ctx.lineWidth = state.lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    const animations = coordinates.reduce((result, currentCoordinate, index) => {\n      const prevCoordinate = coordinates[index - 1];\n\n      if (index === 0) {\n        result.push(() => {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] - 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n          ctx.beginPath();\n        });\n        result = result.concat(calcWaypoints([currentCoordinate[0], currentCoordinate[1] - 3], currentCoordinate).map(waypointMapper));\n      }\n\n      if (prevCoordinate) {\n        result = result.concat(calcWaypoints(prevCoordinate, currentCoordinate).map(waypointMapper));\n      }\n\n      if (index === lastIndex) {\n        result = result.concat(calcWaypoints(currentCoordinate, [currentCoordinate[0], currentCoordinate[1] + 3]).map(waypointMapper));\n        result.push(() => {\n          ctx.stroke();\n          ctx.closePath();\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] + 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n        });\n      }\n\n      return result;\n    }, []);\n    return animations;\n  }, [props, state.coordinates, state.lineWidth]);\n  const calcWaypoints = useCallback((start, end) => {\n    const waypoints = [];\n    const dx = end[0] - start[0];\n    const dy = end[1] - start[1];\n    const frames = Math.round(Math.sqrt(Math.pow(Math.abs(dx), 2) + Math.pow(Math.abs(dy), 2)) / 10);\n\n    for (let i = 0; i <= frames; i++) {\n      const x = start[0] + dx * i / frames;\n      const y = start[1] + dy * i / frames;\n      waypoints.push([x, y]);\n    }\n\n    return waypoints;\n  }, []);\n  const playAnimation = useCallback((animations, useAnimation = false, playAnimationState = {\n    playing: true,\n    playIndex: 0\n  }) => {\n    for (const index in animations) {\n      const isEnd = useAnimation && playAnimationState.playIndex <= Number(index);\n      const animationCallback = animations[index];\n      animationCallback === null || animationCallback === void 0 ? void 0 : animationCallback(isEnd);\n      if (isEnd) break;\n    }\n\n    playAnimationState.playIndex++;\n\n    if (playAnimationState.playing && useAnimation && playAnimationState.playIndex < animations.length) {\n      requestAnimationFrame(() => playAnimation(animations, useAnimation, playAnimationState));\n    }\n\n    return {\n      stopAnimation() {\n        playAnimationState.playing = false;\n      }\n\n    };\n  }, []);\n  return __jsx(\"canvas\", {\n    ref: canvasRef,\n    width: props.width,\n    height: props.height\n  });\n};\n\nexport default ResultCanvas;","map":null,"metadata":{},"sourceType":"module"}