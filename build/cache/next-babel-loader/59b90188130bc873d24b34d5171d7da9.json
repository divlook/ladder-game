{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useRef, useReducer, useCallback, useEffect } from 'react';\nimport clsx from 'clsx';\nimport { Typography, Box, Grid, Button } from '@material-ui/core';\nimport { useStyles } from '~/components/LadderGame.style';\nimport { LadderGameReducer, LadderGameInitialState, LadderGameInitializer } from '~/components/LadderGame.reducer';\nimport * as actions from '~/components/LadderGame.action';\nimport { throttling } from '~/lib/utils';\nimport ResultCanvas from '~/components/ResultCanvas';\n/*\nTODO:\n\n// 클릭=터치\n// block은 1:1로만 연결가능\n// block이 1:1로 연결되면 midLine이 생성됨.\n// midLine은 [prevStep ,nextStep] 데이터를 가지고 있어야됨. 좌표를 저장하는 방법은 2가지가 있음\n// - 1. useMemo를 사용하여 mapData가 변경될 때마다 새로 계산하는 방법\n// - 2. new Map()을 사용하여 변경할때마다 해당 hash만 변경하는 방법\n// 연결되면 isLinked가 true가 되고 더이상 클릭할 수 없음.\n// midLine을 취소할 수 있으며, 취소하면 원상복귀시켜야 됨.\n// 보상은 midLine이 다 그려진 뒤 게임이 시작되기전에 순서를 랜덤으로 섞어야됨\n// resultLine은 mapData의 0부터 시작해서 nextStep을 따라 그려져야됨\n// resultLine이 그려질 때 애니메이션 추가\n결과 데이터 저장\n확률 표시\n\n싱글모드, 멀티모드\n유저정보 입력\n호스트가 게임 생성\n다른 유저들이 게임에 참가\n\n*/\n\nconst LadderGame = props => {\n  const {\n    0: state,\n    1: dispatch\n  } = useReducer(LadderGameReducer, LadderGameInitialState, LadderGameInitializer);\n  const classes = useStyles(state)();\n  const mapRef = useRef(null);\n  const methods = {\n    calcMapSize() {\n      if (mapRef.current) {\n        var _mapRef$current, _mapRef$current2;\n\n        dispatch(actions.updateMapSize((_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.scrollWidth, (_mapRef$current2 = mapRef.current) === null || _mapRef$current2 === void 0 ? void 0 : _mapRef$current2.scrollHeight));\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    paintLadder() {\n      const {\n        ladderQty\n      } = props;\n      dispatch(actions.createMapData(ladderQty));\n    },\n\n    calcMidLineStyle: useCallback((startPoint, endPoint) => {\n      var _startPoint$el, _endPoint$el, _startPoint$el2, _endPoint$el2, _startPoint$el3, _endPoint$el3;\n\n      const toTheSameTop = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el = startPoint.el) === null || _startPoint$el === void 0 ? void 0 : _startPoint$el.offsetTop) || 0) === ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el = endPoint.el) === null || _endPoint$el === void 0 ? void 0 : _endPoint$el.offsetTop) || 0);\n      const toTheBottom = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el2 = startPoint.el) === null || _startPoint$el2 === void 0 ? void 0 : _startPoint$el2.offsetTop) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el2 = endPoint.el) === null || _endPoint$el2 === void 0 ? void 0 : _endPoint$el2.offsetTop) || 0);\n      const toTheRight = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el3 = startPoint.el) === null || _startPoint$el3 === void 0 ? void 0 : _startPoint$el3.offsetLeft) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el3 = endPoint.el) === null || _endPoint$el3 === void 0 ? void 0 : _endPoint$el3.offsetLeft) || 0);\n      const leftPoint = toTheRight ? startPoint : endPoint;\n      const rightPoint = toTheRight ? endPoint : startPoint;\n\n      if ((leftPoint === null || leftPoint === void 0 ? void 0 : leftPoint.el) !== null && (rightPoint === null || rightPoint === void 0 ? void 0 : rightPoint.el) !== null) {\n        const defaultMidLineOption = {\n          width: 8\n        };\n        const style = {\n          display: 'block',\n          top: 0,\n          left: 0,\n          width: defaultMidLineOption.width,\n          height: defaultMidLineOption.width,\n          transform: 'rotate(0deg)'\n        };\n\n        if (toTheSameTop) {\n          const margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n          const addLine = leftPoint.el.offsetWidth - margin * 2;\n          style.width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine;\n          style.left = leftPoint.el.offsetLeft + margin;\n          style.top = leftPoint.el.offsetTop + margin;\n        } else {\n          const margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n          const addLine = leftPoint.el.offsetWidth - margin * 2;\n          const width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine;\n          const height = Math.abs(leftPoint.el.offsetTop - rightPoint.el.offsetTop) + addLine;\n          const angle = Math.atan(height / width) * 180 / Math.PI;\n          style.width = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n          style.left = leftPoint.el.offsetLeft - (style.width - width) / 2;\n          style.top = leftPoint.el.offsetTop + height / 2;\n          style.transform = `rotate(${angle}deg)`; // 방향에 따라 추가 연산\n\n          if (!toTheBottom && toTheRight || !toTheRight && toTheBottom) {\n            style.top += height * -1;\n            style.transform = `rotate(${angle * -1}deg)`;\n          }\n\n          if (toTheBottom && toTheRight || !toTheBottom && !toTheRight) {\n            style.top -= defaultMidLineOption.width / 2;\n          }\n\n          if (!toTheBottom && toTheRight || toTheBottom && !toTheRight) {\n            style.top += defaultMidLineOption.width / 2;\n          } // margin 추가\n\n\n          style.left += margin;\n          style.top += margin;\n        }\n\n        return style;\n      }\n\n      return undefined;\n    }, [state.mapWidth, state.mapHeight]),\n    connectMidLine: (x, y) => e => {\n      var _state$generatingMidL;\n\n      e.persist();\n      console.group('item');\n      console.log('x', x, 'y', y);\n      console.log(state.mapData[x][y]);\n      console.groupEnd(); // handle만 조작 가능하다\n\n      if (!state.mapData[x][y].isHandle) return; // 이미 연결된건 조작 불가능하다\n\n      if (state.mapData[x][y].isLinked) return; // 같은 block을 클릭하면 취소된다\n\n      if (state.mapData[x][y] === state.generatingMidLinePoint) {\n        dispatch(actions.cancelGeneratingMidline());\n        return;\n      } // 같은 라인의 block을 클릭하면 취소된다\n\n\n      if (x === ((_state$generatingMidL = state.generatingMidLinePoint) === null || _state$generatingMidL === void 0 ? void 0 : _state$generatingMidL.x)) {\n        dispatch(actions.cancelGeneratingMidline());\n        return;\n      } // midLine 시작점을 저장한다\n\n\n      if (!state.generatingMidLinePoint) {\n        dispatch(actions.startGeneratingMidline(state.mapData[x][y]));\n        return;\n      } // midLine을 그린다\n\n\n      if (state.generatingMidLinePoint) {\n        dispatch(actions.finishGeneratingMidline(state.mapData[x][y]));\n      }\n    },\n    cutMidLine: midLineIndex => () => {\n      dispatch(actions.removeMidline(midLineIndex));\n    },\n    bindEl: data => el => {\n      data.el = el;\n    },\n    playGame: key => () => {\n      if (!state.completedLineIndexs.includes(key)) {\n        dispatch(actions.playGame(key));\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    doReady() {\n      dispatch(actions.prepareGame(props.rewards));\n    },\n\n    reGame() {\n      dispatch(actions.reGame());\n    },\n\n    handleWindowResize: throttling(() => {\n      methods.calcMapSize();\n    })\n  };\n  useEffect(() => {\n    methods.paintLadder();\n    window.addEventListener('resize', methods.handleWindowResize);\n    return () => {\n      window.removeEventListener('resize', methods.handleWindowResize);\n    };\n  }, []);\n  useEffect(() => {\n    state.hasMapData && methods.calcMapSize();\n  }, [state.hasMapData]);\n  return __jsx(\"div\", {\n    className: classes.root\n  }, (() => {\n    if (!state.hasMapData) {\n      return __jsx(Typography, null, \"\\uC0AC\\uB2E4\\uB9AC\\uAC00 \\uADF8\\uB824\\uC9C0\\uB294 \\uC911 \\uC785\\uB2C8\\uB2E4. \\uAE30\\uB2E4\\uB824\\uC8FC\\uC138\\uC694.\");\n    } else if (state.hasMapData) {\n      return __jsx(React.Fragment, null, __jsx(\"div\", {\n        className: classes.ladders\n      }, __jsx(Grid, {\n        ref: mapRef,\n        className: classes.ladderContainer,\n        container: true,\n        spacing: 2\n      }, state.mapData.map((xVal, xIndex) => {\n        return __jsx(Grid, {\n          key: xIndex,\n          item: true\n        }, __jsx(Box, {\n          className: classes.ladderItemHeader\n        }, __jsx(Button, {\n          className: classes.buttonItem,\n          variant: \"contained\",\n          color: \"primary\",\n          onClick: methods.playGame(xIndex),\n          disabled: state.gameStep === 0 || state.completedLineIndexs.includes(xIndex)\n        }, props.players[xIndex] || `참가자 ${xIndex + 1}`)), __jsx(Box, {\n          className: classes.ladderItem\n        }, xVal.map((yVal, yIndex) => {\n          return __jsx(\"div\", {\n            key: yIndex,\n            ref: methods.bindEl(yVal),\n            className: clsx(classes.ladderItemBlock, {\n              [classes.ladderItemHandle]: yVal.isHandle,\n              active: state.generatingMidLinePoint === yVal,\n              linked: yVal.isLinked\n            }),\n            onClick: methods.connectMidLine(xIndex, yIndex)\n          });\n        })), __jsx(Box, {\n          className: classes.ladderItemFooter\n        }, state.gameStep === 0 && __jsx(Typography, null, \"\\uBCF4\\uC0C1 \", xIndex + 1), state.gameStep > 0 && __jsx(Typography, null, state.rewards[xIndex] || `보상 ${xIndex + 1}`)));\n      }), state.midLineData.map((midLine, midLineIndex) => {\n        return __jsx(\"div\", {\n          key: midLineIndex,\n          ref: methods.bindEl(midLine),\n          className: classes.ladderMidLine,\n          style: methods.calcMidLineStyle(midLine.blocks[0], midLine.blocks[1]),\n          onClick: methods.cutMidLine(midLineIndex)\n        });\n      }), __jsx(\"div\", {\n        className: clsx(classes.result, {\n          active: state.gameStep > 0\n        })\n      }, state.completedLineIndexs.map((lineIndex, index) => {\n        return __jsx(ResultCanvas, {\n          key: index,\n          lineIndex: lineIndex,\n          width: state.mapWidth,\n          height: state.mapHeight,\n          map: state.mapData\n        });\n      })))), __jsx(Grid, {\n        container: true,\n        spacing: 2,\n        className: classes.buttons,\n        justify: \"center\"\n      }, __jsx(Grid, {\n        item: true\n      }, state.gameStep === 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.doReady\n      }, \"\\uC900\\uBE44 \\uC644\\uB8CC\"), state.gameStep > 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.reGame\n      }, \"\\uB2E4\\uC2DC\\uD558\\uAE30\"))));\n    }\n  })());\n};\n\nexport default LadderGame;","map":null,"metadata":{},"sourceType":"module"}