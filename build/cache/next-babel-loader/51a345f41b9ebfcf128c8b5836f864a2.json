{"ast":null,"code":"import _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\nimport React, { useRef, useReducer, useCallback, useEffect } from 'react';\nimport clsx from 'clsx';\nimport { Typography, Box, Grid, Button } from '@material-ui/core';\nimport { useStyles } from '~/components/LadderGame.style';\nimport { LadderGameReducer, LadderGameInitialState, LadderGameInitializer } from '~/components/LadderGame.reducer';\nimport * as actions from '~/components/LadderGame.action';\nimport { throttling } from '~/lib/utils';\nimport ResultCanvas from '~/components/ResultCanvas';\n/*\nTODO:\n\n// 클릭=터치\n// block은 1:1로만 연결가능\n// block이 1:1로 연결되면 midLine이 생성됨.\n// midLine은 [prevStep ,nextStep] 데이터를 가지고 있어야됨. 좌표를 저장하는 방법은 2가지가 있음\n// - 1. useMemo를 사용하여 mapData가 변경될 때마다 새로 계산하는 방법\n// - 2. new Map()을 사용하여 변경할때마다 해당 hash만 변경하는 방법\n// 연결되면 isLinked가 true가 되고 더이상 클릭할 수 없음.\n// midLine을 취소할 수 있으며, 취소하면 원상복귀시켜야 됨.\n// 보상은 midLine이 다 그려진 뒤 게임이 시작되기전에 순서를 랜덤으로 섞어야됨\n// resultLine은 mapData의 0부터 시작해서 nextStep을 따라 그려져야됨\n// resultLine이 그려질 때 애니메이션 추가\n결과 데이터 저장\n확률 표시\n\n싱글모드, 멀티모드\n유저정보 입력\n호스트가 게임 생성\n다른 유저들이 게임에 참가\n\n*/\n\nvar LadderGame = function LadderGame(props) {\n  var _useReducer = useReducer(LadderGameReducer, LadderGameInitialState, LadderGameInitializer),\n      state = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  var classes = useStyles(state)();\n  var mapRef = useRef(null);\n  var methods = {\n    calcMapSize: function calcMapSize() {\n      if (mapRef.current) {\n        var _mapRef$current, _mapRef$current2;\n\n        dispatch(actions.updateMapSize((_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.scrollWidth, (_mapRef$current2 = mapRef.current) === null || _mapRef$current2 === void 0 ? void 0 : _mapRef$current2.scrollHeight));\n        return true;\n      } else {\n        return false;\n      }\n    },\n    paintLadder: function paintLadder() {\n      var ladderQty = props.ladderQty;\n      dispatch(actions.createMapData(ladderQty));\n    },\n    calcMidLineStyle: useCallback(function (startPoint, endPoint) {\n      var _startPoint$el, _endPoint$el, _startPoint$el2, _endPoint$el2, _startPoint$el3, _endPoint$el3;\n\n      var toTheSameTop = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el = startPoint.el) === null || _startPoint$el === void 0 ? void 0 : _startPoint$el.offsetTop) || 0) === ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el = endPoint.el) === null || _endPoint$el === void 0 ? void 0 : _endPoint$el.offsetTop) || 0);\n      var toTheBottom = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el2 = startPoint.el) === null || _startPoint$el2 === void 0 ? void 0 : _startPoint$el2.offsetTop) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el2 = endPoint.el) === null || _endPoint$el2 === void 0 ? void 0 : _endPoint$el2.offsetTop) || 0);\n      var toTheRight = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el3 = startPoint.el) === null || _startPoint$el3 === void 0 ? void 0 : _startPoint$el3.offsetLeft) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el3 = endPoint.el) === null || _endPoint$el3 === void 0 ? void 0 : _endPoint$el3.offsetLeft) || 0);\n      var leftPoint = toTheRight ? startPoint : endPoint;\n      var rightPoint = toTheRight ? endPoint : startPoint;\n\n      if ((leftPoint === null || leftPoint === void 0 ? void 0 : leftPoint.el) !== null && (rightPoint === null || rightPoint === void 0 ? void 0 : rightPoint.el) !== null) {\n        var defaultMidLineOption = {\n          width: 8\n        };\n        var style = {\n          display: 'block',\n          top: 0,\n          left: 0,\n          width: defaultMidLineOption.width,\n          height: defaultMidLineOption.width,\n          transform: 'rotate(0deg)'\n        };\n\n        if (toTheSameTop) {\n          var margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n          var addLine = leftPoint.el.offsetWidth - margin * 2;\n          style.width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine;\n          style.left = leftPoint.el.offsetLeft + margin;\n          style.top = leftPoint.el.offsetTop + margin;\n        } else {\n          var _margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n\n          var _addLine = leftPoint.el.offsetWidth - _margin * 2;\n\n          var width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + _addLine;\n\n          var height = Math.abs(leftPoint.el.offsetTop - rightPoint.el.offsetTop) + _addLine;\n\n          var angle = Math.atan(height / width) * 180 / Math.PI;\n          style.width = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n          style.left = leftPoint.el.offsetLeft - (style.width - width) / 2;\n          style.top = leftPoint.el.offsetTop + height / 2;\n          style.transform = \"rotate(\".concat(angle, \"deg)\"); // 방향에 따라 추가 연산\n\n          if (!toTheBottom && toTheRight || !toTheRight && toTheBottom) {\n            style.top += height * -1;\n            style.transform = \"rotate(\".concat(angle * -1, \"deg)\");\n          }\n\n          if (toTheBottom && toTheRight || !toTheBottom && !toTheRight) {\n            style.top -= defaultMidLineOption.width / 2;\n          }\n\n          if (!toTheBottom && toTheRight || toTheBottom && !toTheRight) {\n            style.top += defaultMidLineOption.width / 2;\n          } // margin 추가\n\n\n          style.left += _margin;\n          style.top += _margin;\n        }\n\n        return style;\n      }\n\n      return undefined;\n    }, [state.mapWidth, state.mapHeight]),\n    connectMidLine: function connectMidLine(x, y) {\n      return function (e) {\n        var _state$generatingMidL;\n\n        e.persist();\n        console.group('item');\n        console.log('x', x, 'y', y);\n        console.log(state.mapData[x][y]);\n        console.groupEnd(); // handle만 조작 가능하다\n\n        if (!state.mapData[x][y].isHandle) return; // 이미 연결된건 조작 불가능하다\n\n        if (state.mapData[x][y].isLinked) return; // 같은 block을 클릭하면 취소된다\n\n        if (state.mapData[x][y] === state.generatingMidLinePoint) {\n          dispatch(actions.cancelGeneratingMidline());\n          return;\n        } // 같은 라인의 block을 클릭하면 취소된다\n\n\n        if (x === ((_state$generatingMidL = state.generatingMidLinePoint) === null || _state$generatingMidL === void 0 ? void 0 : _state$generatingMidL.x)) {\n          dispatch(actions.cancelGeneratingMidline());\n          return;\n        } // midLine 시작점을 저장한다\n\n\n        if (!state.generatingMidLinePoint) {\n          dispatch(actions.startGeneratingMidline(state.mapData[x][y]));\n          return;\n        } // midLine을 그린다\n\n\n        if (state.generatingMidLinePoint) {\n          dispatch(actions.finishGeneratingMidline(state.mapData[x][y]));\n        }\n      };\n    },\n    cutMidLine: function cutMidLine(midLineIndex) {\n      return function () {\n        dispatch(actions.removeMidline(midLineIndex));\n      };\n    },\n    bindEl: function bindEl(data) {\n      return function (el) {\n        data.el = el;\n      };\n    },\n    playGame: function playGame(key) {\n      return function () {\n        if (!state.completedLineIndexs.includes(key)) {\n          dispatch(actions.playGame(key));\n          return true;\n        } else {\n          return false;\n        }\n      };\n    },\n    doReady: function doReady() {\n      dispatch(actions.prepareGame(props.rewards));\n    },\n    reGame: function reGame() {\n      dispatch(actions.reGame());\n    },\n    handleWindowResize: throttling(function () {\n      methods.calcMapSize();\n    })\n  };\n  useEffect(function () {\n    methods.paintLadder();\n    window.addEventListener('resize', methods.handleWindowResize);\n    return function () {\n      window.removeEventListener('resize', methods.handleWindowResize);\n    };\n  }, []);\n  useEffect(function () {\n    state.hasMapData && methods.calcMapSize();\n  }, [state.hasMapData]);\n  return __jsx(\"div\", {\n    className: classes.root\n  }, function () {\n    if (!state.hasMapData) {\n      return __jsx(Typography, null, \"\\uC0AC\\uB2E4\\uB9AC\\uAC00 \\uADF8\\uB824\\uC9C0\\uB294 \\uC911 \\uC785\\uB2C8\\uB2E4. \\uAE30\\uB2E4\\uB824\\uC8FC\\uC138\\uC694.\");\n    } else if (state.hasMapData) {\n      return __jsx(React.Fragment, null, __jsx(\"div\", {\n        className: classes.ladders\n      }, __jsx(Grid, {\n        ref: mapRef,\n        className: classes.ladderContainer,\n        container: true,\n        spacing: 2\n      }, state.mapData.map(function (xVal, xIndex) {\n        return __jsx(Grid, {\n          key: xIndex,\n          item: true\n        }, __jsx(Box, {\n          className: classes.ladderItemHeader\n        }, __jsx(Button, {\n          className: classes.buttonItem,\n          variant: \"contained\",\n          color: \"primary\",\n          onClick: methods.playGame(xIndex),\n          disabled: state.gameStep === 0 || state.completedLineIndexs.includes(xIndex)\n        }, props.players[xIndex] || \"\\uCC38\\uAC00\\uC790 \".concat(xIndex + 1))), __jsx(Box, {\n          className: classes.ladderItem\n        }, xVal.map(function (yVal, yIndex) {\n          var _clsx;\n\n          return __jsx(\"div\", {\n            key: yIndex,\n            ref: methods.bindEl(yVal),\n            className: clsx(classes.ladderItemBlock, (_clsx = {}, _defineProperty(_clsx, classes.ladderItemHandle, yVal.isHandle), _defineProperty(_clsx, \"active\", state.generatingMidLinePoint === yVal), _defineProperty(_clsx, \"linked\", yVal.isLinked), _clsx)),\n            onClick: methods.connectMidLine(xIndex, yIndex)\n          });\n        })), __jsx(Box, {\n          className: classes.ladderItemFooter\n        }, state.gameStep === 0 && __jsx(Typography, null, \"\\uBCF4\\uC0C1 \", xIndex + 1), state.gameStep > 0 && __jsx(Typography, null, state.rewards[xIndex] || \"\\uBCF4\\uC0C1 \".concat(xIndex + 1))));\n      }), state.midLineData.map(function (midLine, midLineIndex) {\n        return __jsx(\"div\", {\n          key: midLineIndex,\n          ref: methods.bindEl(midLine),\n          className: classes.ladderMidLine,\n          style: methods.calcMidLineStyle(midLine.blocks[0], midLine.blocks[1]),\n          onClick: methods.cutMidLine(midLineIndex)\n        });\n      }), __jsx(\"div\", {\n        className: clsx(classes.result, {\n          active: state.gameStep > 0\n        })\n      }, state.completedLineIndexs.map(function (lineIndex, index) {\n        return __jsx(ResultCanvas, {\n          key: index,\n          lineIndex: lineIndex,\n          width: state.mapWidth,\n          height: state.mapHeight,\n          map: state.mapData\n        });\n      })))), __jsx(Grid, {\n        container: true,\n        spacing: 2,\n        className: classes.buttons,\n        justify: \"center\"\n      }, __jsx(Grid, {\n        item: true\n      }, state.gameStep === 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.doReady\n      }, \"\\uC900\\uBE44 \\uC644\\uB8CC\"), state.gameStep > 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.reGame\n      }, \"\\uB2E4\\uC2DC\\uD558\\uAE30\"))));\n    }\n  }());\n};\n\nLadderGame.displayName = \"LadderGame\";\nexport default LadderGame;","map":{"version":3,"sources":["/Users/chad/_workspace/ladder-game/components/LadderGame.tsx"],"names":["React","useRef","useReducer","useCallback","useEffect","clsx","Typography","Box","Grid","Button","useStyles","LadderGameReducer","LadderGameInitialState","LadderGameInitializer","actions","throttling","ResultCanvas","LadderGame","props","state","dispatch","classes","mapRef","methods","calcMapSize","current","updateMapSize","scrollWidth","scrollHeight","paintLadder","ladderQty","createMapData","calcMidLineStyle","startPoint","endPoint","toTheSameTop","el","offsetTop","toTheBottom","toTheRight","offsetLeft","leftPoint","rightPoint","defaultMidLineOption","width","style","display","top","left","height","transform","margin","offsetWidth","addLine","Math","abs","angle","atan","PI","sqrt","pow","undefined","mapWidth","mapHeight","connectMidLine","x","y","e","persist","console","group","log","mapData","groupEnd","isHandle","isLinked","generatingMidLinePoint","cancelGeneratingMidline","startGeneratingMidline","finishGeneratingMidline","cutMidLine","midLineIndex","removeMidline","bindEl","data","playGame","key","completedLineIndexs","includes","doReady","prepareGame","rewards","reGame","handleWindowResize","window","addEventListener","removeEventListener","hasMapData","root","ladders","ladderContainer","map","xVal","xIndex","ladderItemHeader","buttonItem","gameStep","players","ladderItem","yVal","yIndex","ladderItemBlock","ladderItemHandle","ladderItemFooter","midLineData","midLine","ladderMidLine","blocks","result","active","lineIndex","index","buttons"],"mappings":"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","sourcesContent":["import React, { useRef, useReducer, useCallback, useEffect } from 'react'\nimport clsx from 'clsx'\nimport { Typography, Box, Grid, Button } from '@material-ui/core'\nimport { InitialState } from '~/reducers/index.type'\nimport { MapData } from '~/components/LadderGame.interface'\nimport { useStyles } from '~/components/LadderGame.style'\nimport { LadderGameReducer, LadderGameInitialState, LadderGameInitializer } from '~/components/LadderGame.reducer'\nimport * as actions from '~/components/LadderGame.action'\nimport { throttling } from '~/lib/utils'\nimport ResultCanvas from '~/components/ResultCanvas'\n\n/*\nTODO:\n\n// 클릭=터치\n// block은 1:1로만 연결가능\n// block이 1:1로 연결되면 midLine이 생성됨.\n// midLine은 [prevStep ,nextStep] 데이터를 가지고 있어야됨. 좌표를 저장하는 방법은 2가지가 있음\n// - 1. useMemo를 사용하여 mapData가 변경될 때마다 새로 계산하는 방법\n// - 2. new Map()을 사용하여 변경할때마다 해당 hash만 변경하는 방법\n// 연결되면 isLinked가 true가 되고 더이상 클릭할 수 없음.\n// midLine을 취소할 수 있으며, 취소하면 원상복귀시켜야 됨.\n// 보상은 midLine이 다 그려진 뒤 게임이 시작되기전에 순서를 랜덤으로 섞어야됨\n// resultLine은 mapData의 0부터 시작해서 nextStep을 따라 그려져야됨\n// resultLine이 그려질 때 애니메이션 추가\n결과 데이터 저장\n확률 표시\n\n싱글모드, 멀티모드\n유저정보 입력\n호스트가 게임 생성\n다른 유저들이 게임에 참가\n\n*/\n\nconst LadderGame: React.FC<InitialState> = props => {\n    const [state, dispatch] = useReducer(LadderGameReducer, LadderGameInitialState, LadderGameInitializer)\n    const classes = useStyles(state)()\n\n    const mapRef = useRef<HTMLDivElement>(null)\n\n    const methods = {\n        calcMapSize() {\n            if (mapRef.current) {\n                dispatch(actions.updateMapSize(mapRef.current?.scrollWidth, mapRef.current?.scrollHeight))\n                return true\n            } else {\n                return false\n            }\n        },\n        paintLadder() {\n            const { ladderQty } = props\n\n            dispatch(actions.createMapData(ladderQty))\n        },\n        calcMidLineStyle: useCallback(\n            (startPoint: MapData, endPoint: MapData) => {\n                const toTheSameTop = (startPoint?.el?.offsetTop || 0) === (endPoint?.el?.offsetTop || 0)\n                const toTheBottom = (startPoint?.el?.offsetTop || 0) < (endPoint?.el?.offsetTop || 0)\n                const toTheRight = (startPoint?.el?.offsetLeft || 0) < (endPoint?.el?.offsetLeft || 0)\n\n                const leftPoint = toTheRight ? startPoint : endPoint\n                const rightPoint = toTheRight ? endPoint : startPoint\n\n                if (leftPoint?.el !== null && rightPoint?.el !== null) {\n                    const defaultMidLineOption = {\n                        width: 8,\n                    }\n                    const style = {\n                        display: 'block',\n                        top: 0,\n                        left: 0,\n                        width: defaultMidLineOption.width,\n                        height: defaultMidLineOption.width,\n                        transform: 'rotate(0deg)',\n                    }\n\n                    if (toTheSameTop) {\n                        const margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2\n                        const addLine = leftPoint.el.offsetWidth - margin * 2\n                        style.width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine\n                        style.left = leftPoint.el.offsetLeft + margin\n                        style.top = leftPoint.el.offsetTop + margin\n                    } else {\n                        const margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2\n                        const addLine = leftPoint.el.offsetWidth - margin * 2\n                        const width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine\n                        const height = Math.abs(leftPoint.el.offsetTop - rightPoint.el.offsetTop) + addLine\n                        const angle = (Math.atan(height / width) * 180) / Math.PI\n\n                        style.width = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2))\n                        style.left = leftPoint.el.offsetLeft - (style.width - width) / 2\n                        style.top = leftPoint.el.offsetTop + height / 2\n                        style.transform = `rotate(${angle}deg)`\n\n                        // 방향에 따라 추가 연산\n                        if ((!toTheBottom && toTheRight) || (!toTheRight && toTheBottom)) {\n                            style.top += height * -1\n                            style.transform = `rotate(${angle * -1}deg)`\n                        }\n                        if ((toTheBottom && toTheRight) || (!toTheBottom && !toTheRight)) {\n                            style.top -= defaultMidLineOption.width / 2\n                        }\n                        if ((!toTheBottom && toTheRight) || (toTheBottom && !toTheRight)) {\n                            style.top += defaultMidLineOption.width / 2\n                        }\n\n                        // margin 추가\n                        style.left += margin\n                        style.top += margin\n                    }\n\n                    return style\n                }\n                return undefined\n            },\n            [state.mapWidth, state.mapHeight]\n        ),\n        connectMidLine: (x: number, y: number) => e => {\n            e.persist()\n            console.group('item')\n            console.log('x', x, 'y', y)\n            console.log(state.mapData[x][y])\n            console.groupEnd()\n\n            // handle만 조작 가능하다\n            if (!state.mapData[x][y].isHandle) return\n\n            // 이미 연결된건 조작 불가능하다\n            if (state.mapData[x][y].isLinked) return\n\n            // 같은 block을 클릭하면 취소된다\n            if (state.mapData[x][y] === state.generatingMidLinePoint) {\n                dispatch(actions.cancelGeneratingMidline())\n                return\n            }\n\n            // 같은 라인의 block을 클릭하면 취소된다\n            if (x === state.generatingMidLinePoint?.x) {\n                dispatch(actions.cancelGeneratingMidline())\n                return\n            }\n\n            // midLine 시작점을 저장한다\n            if (!state.generatingMidLinePoint) {\n                dispatch(actions.startGeneratingMidline(state.mapData[x][y]))\n                return\n            }\n\n            // midLine을 그린다\n            if (state.generatingMidLinePoint) {\n                dispatch(actions.finishGeneratingMidline(state.mapData[x][y]))\n            }\n        },\n        cutMidLine: (midLineIndex: number) => () => {\n            dispatch(actions.removeMidline(midLineIndex))\n        },\n        bindEl: data => el => {\n            data.el = el\n        },\n        playGame: key => () => {\n            if (!state.completedLineIndexs.includes(key)) {\n                dispatch(actions.playGame(key))\n                return true\n            } else {\n                return false\n            }\n        },\n        doReady() {\n            dispatch(actions.prepareGame(props.rewards))\n        },\n        reGame() {\n            dispatch(actions.reGame())\n        },\n        handleWindowResize: throttling(() => {\n            methods.calcMapSize()\n        }),\n    }\n\n    useEffect(() => {\n        methods.paintLadder()\n        window.addEventListener('resize', methods.handleWindowResize)\n\n        return () => {\n            window.removeEventListener('resize', methods.handleWindowResize)\n        }\n    }, [])\n\n    useEffect(() => {\n        state.hasMapData && methods.calcMapSize()\n    }, [state.hasMapData])\n\n    return (\n        <div className={classes.root}>\n            {(() => {\n                if (!state.hasMapData) {\n                    return <Typography>사다리가 그려지는 중 입니다. 기다려주세요.</Typography>\n                } else if (state.hasMapData) {\n                    return (\n                        <React.Fragment>\n                            <div className={classes.ladders}>\n                                <Grid ref={mapRef} className={classes.ladderContainer} container spacing={2}>\n                                    {state.mapData.map((xVal, xIndex) => {\n                                        return (\n                                            <Grid key={xIndex} item>\n                                                <Box className={classes.ladderItemHeader}>\n                                                    <Button\n                                                        className={classes.buttonItem}\n                                                        variant=\"contained\"\n                                                        color=\"primary\"\n                                                        onClick={methods.playGame(xIndex)}\n                                                        disabled={state.gameStep === 0 || state.completedLineIndexs.includes(xIndex)}\n                                                    >\n                                                        {props.players[xIndex] || `참가자 ${xIndex + 1}`}\n                                                    </Button>\n                                                </Box>\n                                                <Box className={classes.ladderItem}>\n                                                    {xVal.map((yVal, yIndex) => {\n                                                        return (\n                                                            <div\n                                                                key={yIndex}\n                                                                ref={methods.bindEl(yVal)}\n                                                                className={clsx(classes.ladderItemBlock, {\n                                                                    [classes.ladderItemHandle]: yVal.isHandle,\n                                                                    active: state.generatingMidLinePoint === yVal,\n                                                                    linked: yVal.isLinked,\n                                                                })}\n                                                                onClick={methods.connectMidLine(xIndex, yIndex)}\n                                                            />\n                                                        )\n                                                    })}\n                                                </Box>\n                                                <Box className={classes.ladderItemFooter}>\n                                                    {state.gameStep === 0 && <Typography>보상 {xIndex + 1}</Typography>}\n                                                    {state.gameStep > 0 && (\n                                                        <Typography>{state.rewards[xIndex] || `보상 ${xIndex + 1}`}</Typography>\n                                                    )}\n                                                </Box>\n                                            </Grid>\n                                        )\n                                    })}\n                                    {state.midLineData.map((midLine, midLineIndex) => {\n                                        return (\n                                            <div\n                                                key={midLineIndex}\n                                                ref={methods.bindEl(midLine)}\n                                                className={classes.ladderMidLine}\n                                                style={methods.calcMidLineStyle(midLine.blocks[0], midLine.blocks[1])}\n                                                onClick={methods.cutMidLine(midLineIndex)}\n                                            />\n                                        )\n                                    })}\n                                    <div className={clsx(classes.result, { active: state.gameStep > 0 })}>\n                                        {state.completedLineIndexs.map((lineIndex, index) => {\n                                            return (\n                                                <ResultCanvas\n                                                    key={index}\n                                                    lineIndex={lineIndex}\n                                                    width={state.mapWidth}\n                                                    height={state.mapHeight}\n                                                    map={state.mapData}\n                                                />\n                                            )\n                                        })}\n                                    </div>\n                                </Grid>\n                            </div>\n\n                            <Grid container spacing={2} className={classes.buttons} justify=\"center\">\n                                <Grid item>\n                                    {state.gameStep === 0 && (\n                                        <Button\n                                            className={classes.buttonItem}\n                                            variant=\"contained\"\n                                            color=\"secondary\"\n                                            size=\"large\"\n                                            onClick={methods.doReady}\n                                        >\n                                            준비 완료\n                                        </Button>\n                                    )}\n                                    {state.gameStep > 0 && (\n                                        <Button\n                                            className={classes.buttonItem}\n                                            variant=\"contained\"\n                                            color=\"secondary\"\n                                            size=\"large\"\n                                            onClick={methods.reGame}\n                                        >\n                                            다시하기\n                                        </Button>\n                                    )}\n                                </Grid>\n                            </Grid>\n                        </React.Fragment>\n                    )\n                }\n            })()}\n        </div>\n    )\n}\n\nexport default LadderGame\n"]},"metadata":{},"sourceType":"module"}