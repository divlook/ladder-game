{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { colors } from '~/components/LadderGame.style';\n\nvar ResultCanvas = function ResultCanvas(props) {\n  var canvasRef = useRef(null);\n\n  var _useState = useState(false),\n      mounted = _useState[0],\n      setMount = _useState[1];\n\n  var _useState2 = useState(function () {\n    return {\n      coordinates: [],\n      lineWidth: 3,\n      animations: []\n    };\n  }),\n      state = _useState2[0],\n      setState = _useState2[1];\n\n  useEffect(function () {\n    var _drawCanvas = drawCanvas(true),\n        stopAnimation = _drawCanvas.stopAnimation;\n\n    setMount(true);\n    return function () {\n      stopAnimation();\n    };\n  }, []);\n  useEffect(function () {\n    if (mounted) {\n      drawCanvas();\n    }\n  }, [props]);\n  var drawCanvas = useCallback(function () {\n    var isManual = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var coordinates = calcCoordinates();\n    var animations = makeAnimations(coordinates);\n    setState(function (prevState) {\n      return _objectSpread({}, prevState, {\n        animations: animations,\n        coordinates: coordinates\n      });\n    });\n    return playAnimation(animations, isManual);\n  }, []);\n  var calcCoordinates = useCallback(function () {\n    var coordinates = [];\n    var prevBlockUid = 0;\n    var current = props.map[props.lineIndex][0];\n\n    while (current !== null) {\n      var _current;\n\n      var next = null;\n\n      if (current.nextBlock) {\n        if (coordinates.length === 0) {\n          var _current$el, _current$el2, _current$el3;\n\n          // 시작\n          coordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - state.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n          next = current.nextBlock;\n        } else if (current.linkedBlock) {\n          if (current.isHandle) {\n            var _current$el4, _current$el5, _current$el6, _current$el7;\n\n            coordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - state.lineWidth) / 2]);\n          }\n\n          if (current.linkedBlock.uid === prevBlockUid) {\n            // midLine 이동 후\n            next = current.nextBlock;\n          } else {\n            // midLine 이동 전\n            next = current.linkedBlock;\n          }\n        } else {\n          // 일반 block\n          next = current.nextBlock;\n        }\n      } else {\n        var _current$el8, _current$el9, _current$el10, _current$el11;\n\n        // 끝\n        coordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n      }\n\n      prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n      current = next;\n    }\n\n    return coordinates;\n  }, [props.map, props.lineIndex, state.lineWidth]);\n  var makeAnimations = useCallback(function () {\n    var coordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : state.coordinates;\n    if (!canvasRef.current || !props.width || !props.height) return [];\n    canvasRef.current.width = props.width;\n    canvasRef.current.height = props.height;\n    var canvas = canvasRef.current;\n    var ctx = canvas.getContext('2d');\n    var color = colors[props.lineIndex % colors.length];\n    if (!ctx) return [];\n    var lastIndex = coordinates.length - 1;\n\n    var waypointMapper = function waypointMapper(waypoint) {\n      return function (isEnd) {\n        ctx.lineTo.apply(ctx, _toConsumableArray(waypoint));\n        isEnd && ctx.stroke();\n      };\n    };\n\n    ctx.lineWidth = state.lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    var animations = coordinates.reduce(function (result, currentCoordinate, index) {\n      var prevCoordinate = coordinates[index - 1];\n\n      if (index === 0) {\n        result.push(function () {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] - 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n          ctx.beginPath();\n        });\n        result = result.concat(calcWaypoints([currentCoordinate[0], currentCoordinate[1] - 3], currentCoordinate).map(waypointMapper));\n      }\n\n      if (prevCoordinate) {\n        result = result.concat(calcWaypoints(prevCoordinate, currentCoordinate).map(waypointMapper));\n      }\n\n      if (index === lastIndex) {\n        result = result.concat(calcWaypoints(currentCoordinate, [currentCoordinate[0], currentCoordinate[1] + 3]).map(waypointMapper));\n        result.push(function () {\n          ctx.stroke();\n          ctx.closePath();\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] + 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n        });\n      }\n\n      return result;\n    }, []);\n    return animations;\n  }, [props, state.coordinates, state.lineWidth]);\n  var calcWaypoints = useCallback(function (start, end) {\n    var waypoints = [];\n    var dx = end[0] - start[0];\n    var dy = end[1] - start[1];\n    var frames = Math.round(Math.sqrt(Math.pow(Math.abs(dx), 2) + Math.pow(Math.abs(dy), 2)) / 10);\n\n    for (var i = 0; i <= frames; i++) {\n      var x = start[0] + dx * i / frames;\n      var y = start[1] + dy * i / frames;\n      waypoints.push([x, y]);\n    }\n\n    return waypoints;\n  }, []);\n  var playAnimation = useCallback(function (animations) {\n    var useAnimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var playAnimationState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      playing: true,\n      playIndex: 0\n    };\n\n    for (var index in animations) {\n      var _isEnd = useAnimation && playAnimationState.playIndex <= Number(index);\n\n      var animationCallback = animations[index];\n      animationCallback === null || animationCallback === void 0 ? void 0 : animationCallback(_isEnd);\n      if (_isEnd) break;\n    }\n\n    playAnimationState.playIndex++;\n\n    if (playAnimationState.playing && useAnimation && playAnimationState.playIndex < animations.length) {\n      requestAnimationFrame(function () {\n        return playAnimation(animations, useAnimation, playAnimationState);\n      });\n    }\n\n    return {\n      stopAnimation: function stopAnimation() {\n        playAnimationState.playing = false;\n      }\n    };\n  }, []);\n  return __jsx(\"canvas\", {\n    ref: canvasRef,\n    width: props.width,\n    height: props.height\n  });\n};\n\nResultCanvas.displayName = \"ResultCanvas\";\nexport default ResultCanvas;","map":{"version":3,"sources":["/Users/chad/_workspace/ladder-game/components/ResultCanvas.tsx"],"names":["React","useRef","useEffect","useState","useCallback","colors","ResultCanvas","props","canvasRef","mounted","setMount","coordinates","lineWidth","animations","state","setState","drawCanvas","stopAnimation","isManual","calcCoordinates","makeAnimations","prevState","playAnimation","prevBlockUid","current","map","lineIndex","next","nextBlock","length","push","el","offsetLeft","offsetWidth","offsetTop","linkedBlock","isHandle","offsetHeight","uid","width","height","canvas","ctx","getContext","color","lastIndex","waypointMapper","waypoint","isEnd","lineTo","stroke","lineCap","lineJoin","strokeStyle","fillStyle","reduce","result","currentCoordinate","index","prevCoordinate","clearRect","beginPath","arc","Math","PI","closePath","fill","concat","calcWaypoints","start","end","waypoints","dx","dy","frames","round","sqrt","pow","abs","i","x","y","useAnimation","playAnimationState","playing","playIndex","Number","animationCallback","requestAnimationFrame"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react'\nimport { MapData } from '~/components/LadderGame.interface'\nimport { colors } from '~/components/LadderGame.style'\n\ninterface ResultCanvasProps {\n    lineIndex: number\n    width: number\n    height: number\n    map: MapData[][]\n}\n\ninterface ResultCanvasState {\n    coordinates: Waypoint[]\n    lineWidth: number\n    animations: AnimationCallback[]\n}\n\ntype Waypoint = [number, number]\ntype AnimationCallback = (isEnd: boolean) => void\n\nconst ResultCanvas: React.FC<ResultCanvasProps> = props => {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n    const [mounted, setMount] = useState(false)\n    const [state, setState] = useState<ResultCanvasState>(() => {\n        return {\n            coordinates: [],\n            lineWidth: 3,\n            animations: [],\n        }\n    })\n\n    useEffect(() => {\n        const { stopAnimation } = drawCanvas(true)\n        setMount(true)\n\n        return () => {\n            stopAnimation()\n        }\n    }, [])\n\n    useEffect(() => {\n        if (mounted) {\n            drawCanvas()\n        }\n    }, [props])\n\n    const drawCanvas = useCallback((isManual = false) => {\n        const coordinates = calcCoordinates()\n        const animations = makeAnimations(coordinates)\n\n        setState(prevState => ({\n            ...prevState,\n            animations,\n            coordinates,\n        }))\n\n        return playAnimation(animations, isManual)\n    }, [])\n\n    const calcCoordinates = useCallback(() => {\n        const coordinates: Waypoint[] = []\n        let prevBlockUid = 0\n        let current: MapData | null = props.map[props.lineIndex][0]\n\n        while (current !== null) {\n            let next: MapData | null = null\n            if (current.nextBlock) {\n                if (coordinates.length === 0) {\n                    // 시작\n                    coordinates.push([\n                        (current.el?.offsetLeft || 0) + (current.el?.offsetWidth || 0 - state.lineWidth) / 2,\n                        current.el?.offsetTop || 0,\n                    ])\n\n                    next = current.nextBlock\n                } else if (current.linkedBlock) {\n                    if (current.isHandle) {\n                        coordinates.push([\n                            (current.el?.offsetLeft || 0) + (current.el?.offsetWidth || 0 - state.lineWidth) / 2,\n                            (current.el?.offsetTop || 0) + (current.el?.offsetHeight || 0 - state.lineWidth) / 2,\n                        ])\n                    }\n\n                    if (current.linkedBlock.uid === prevBlockUid) {\n                        // midLine 이동 후\n                        next = current.nextBlock\n                    } else {\n                        // midLine 이동 전\n                        next = current.linkedBlock\n                    }\n                } else {\n                    // 일반 block\n                    next = current.nextBlock\n                }\n            } else {\n                // 끝\n                coordinates.push([\n                    (current.el?.offsetLeft || 0) + (current.el?.offsetWidth || 0 - state.lineWidth) / 2,\n                    (current.el?.offsetTop || 0) + (current.el?.offsetHeight || 0),\n                ])\n            }\n\n            prevBlockUid = current?.uid || 0\n            current = next\n        }\n\n        return coordinates\n    }, [props.map, props.lineIndex, state.lineWidth])\n\n    const makeAnimations = useCallback(\n        (coordinates = state.coordinates) => {\n            if (!canvasRef.current || !props.width || !props.height) return []\n\n            canvasRef.current.width = props.width\n            canvasRef.current.height = props.height\n\n            const canvas = canvasRef.current\n            const ctx = canvas.getContext('2d')\n            const color = colors[props.lineIndex % colors.length]\n\n            if (!ctx) return []\n\n            const lastIndex = coordinates.length - 1\n            const waypointMapper = (waypoint: Waypoint) => isEnd => {\n                ctx.lineTo(...waypoint)\n                isEnd && ctx.stroke()\n            }\n\n            ctx.lineWidth = state.lineWidth\n            ctx.lineCap = 'round'\n            ctx.lineJoin = 'round'\n            ctx.strokeStyle = color\n            ctx.fillStyle = color\n\n            const animations = coordinates.reduce((result: AnimationCallback[], currentCoordinate, index) => {\n                const prevCoordinate = coordinates[index - 1]\n\n                if (index === 0) {\n                    result.push(() => {\n                        ctx.clearRect(0, 0, canvas.width, canvas.height)\n                        ctx.beginPath()\n                        ctx.arc(currentCoordinate[0], currentCoordinate[1] - 8, 6, 0, Math.PI * 2)\n                        ctx.closePath()\n                        ctx.fill()\n                        ctx.beginPath()\n                    })\n\n                    result = result.concat(\n                        calcWaypoints([currentCoordinate[0], currentCoordinate[1] - 3], currentCoordinate).map(waypointMapper)\n                    )\n                }\n\n                if (prevCoordinate) {\n                    result = result.concat(calcWaypoints(prevCoordinate, currentCoordinate).map(waypointMapper))\n                }\n\n                if (index === lastIndex) {\n                    result = result.concat(\n                        calcWaypoints(currentCoordinate, [currentCoordinate[0], currentCoordinate[1] + 3]).map(waypointMapper)\n                    )\n                    result.push(() => {\n                        ctx.stroke()\n                        ctx.closePath()\n                        ctx.beginPath()\n                        ctx.arc(currentCoordinate[0], currentCoordinate[1] + 8, 6, 0, Math.PI * 2)\n                        ctx.closePath()\n                        ctx.fill()\n                    })\n                }\n\n                return result\n            }, [])\n\n            return animations\n        },\n        [props, state.coordinates, state.lineWidth]\n    )\n\n    const calcWaypoints = useCallback((start: number[], end: number[]) => {\n        const waypoints: Waypoint[] = []\n        const dx = end[0] - start[0]\n        const dy = end[1] - start[1]\n        const frames = Math.round(Math.sqrt(Math.pow(Math.abs(dx), 2) + Math.pow(Math.abs(dy), 2)) / 10)\n\n        for (let i = 0; i <= frames; i++) {\n            const x = start[0] + (dx * i) / frames\n            const y = start[1] + (dy * i) / frames\n\n            waypoints.push([x, y])\n        }\n\n        return waypoints\n    }, [])\n\n    const playAnimation = useCallback(\n        (animations: AnimationCallback[], useAnimation = false, playAnimationState = { playing: true, playIndex: 0 }) => {\n            for (const index in animations) {\n                const isEnd = useAnimation && playAnimationState.playIndex <= Number(index)\n                const animationCallback = animations[index]\n                animationCallback?.(isEnd)\n                if (isEnd) break\n            }\n\n            playAnimationState.playIndex++\n\n            if (playAnimationState.playing && useAnimation && playAnimationState.playIndex < animations.length) {\n                requestAnimationFrame(() => playAnimation(animations, useAnimation, playAnimationState))\n            }\n\n            return {\n                stopAnimation() {\n                    playAnimationState.playing = false\n                },\n            }\n        },\n        []\n    )\n\n    return <canvas ref={canvasRef} width={props.width} height={props.height} />\n}\n\nexport default ResultCanvas\n"]},"metadata":{},"sourceType":"module"}