{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { Typography, Box, Grid, makeStyles, Button } from '@material-ui/core';\nimport { useLifecycle } from '~/hooks/lifecycle';\n/*\nTODO:\n\n// 클릭=터치\n// block은 1:1로만 연결가능\n// block이 1:1로 연결되면 midLine이 생성됨.\n// midLine은 [prevStep ,nextStep] 데이터를 가지고 있어야됨. 좌표를 저장하는 방법은 2가지가 있음\n// - 1. useMemo를 사용하여 mapData가 변경될 때마다 새로 계산하는 방법\n// - 2. new Map()을 사용하여 변경할때마다 해당 hash만 변경하는 방법\n// 연결되면 isLinked가 true가 되고 더이상 클릭할 수 없음.\n// midLine을 취소할 수 있으며, 취소하면 원상복귀시켜야 됨.\n// 보상은 midLine이 다 그려진 뒤 게임이 시작되기전에 순서를 랜덤으로 섞어야됨\n// resultLine은 mapData의 0부터 시작해서 nextStep을 따라 그려져야됨\nresultLine이 그려질 때 애니메이션 추가\n결과 데이터 저장\n확률 표시\n\n싱글모드, 멀티모드\n유저정보 입력\n호스트가 게임 생성\n다른 유저들이 게임에 참가\n\n*/\n\nexport var defaultOption = {\n  mapMinHeight: 300\n};\nexport var initialState = {\n  isPaintingLadder: false,\n  isPaintedLadder: false,\n  mapData: [],\n  mapWidth: 0,\n  mapHeight: defaultOption.mapMinHeight,\n  ladderBlockCnt: 21,\n  midLineData: [],\n  generatingMidLinePoint: null,\n  gameStep: 0,\n  completedLineIndexs: [],\n  colorIndex: 0,\n  rewards: []\n};\n\nvar useStyles = function useStyles(state) {\n  return makeStyles(function (theme) {\n    return {\n      root: {\n        width: '100%',\n        minHeight: state.mapHeight,\n        position: 'relative'\n      },\n      ladders: {\n        position: 'relative',\n        zIndex: 1,\n        width: '100%',\n        minHeight: state.mapHeight,\n        overflowX: 'auto',\n        overflowY: 'hidden'\n      },\n      ladderContainer: {\n        width: 'auto',\n        justifyContent: 'space-between',\n        flexWrap: 'nowrap'\n      },\n      ladderItem: {\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        minWidth: 80\n      },\n      ladderItemHeader: {\n        textAlign: 'center',\n        marginBottom: theme.spacing(2)\n      },\n      ladderItemFooter: {\n        textAlign: 'center',\n        marginTop: theme.spacing(2)\n      },\n      ladderItemBlock: {\n        position: 'relative',\n        backgroundColor: '#9e7662',\n        width: 10,\n        height: 32,\n        '&:first-child': {\n          borderTopLeftRadius: 3,\n          borderTopRightRadius: 3\n        },\n        '&:last-child': {\n          borderBottomLeftRadius: 3,\n          borderBottomRightRadius: 3\n        }\n      },\n      ladderItemHandle: {\n        cursor: 'pointer',\n        width: 12,\n        height: 12,\n        borderRadius: 2,\n        backgroundColor: '#795548',\n        '&:hover:not(.linked), &.active': {\n          zIndex: 1,\n          boxShadow: '0 0 8px 4px rgba(255, 255, 255, 0.4), 0 0 12px 12px rgb(158, 118, 98, 0.6)'\n        },\n        '&.linked': {\n          cursor: 'no-drop'\n        }\n      },\n      ladderMidLine: {\n        display: 'none',\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        zIndex: 2,\n        backgroundColor: '#795548',\n        width: 8,\n        height: 8,\n        borderRadius: 4,\n        boxShadow: '0 2px 4px 2px rgba(0, 0, 0, 0.2)',\n        cursor: 'pointer'\n      },\n      result: {\n        display: 'none',\n        position: 'absolute',\n        zIndex: 999,\n        width: '100%',\n        height: '100%',\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0,\n        '&.active': {\n          display: 'block'\n        },\n        '& canvas': {\n          position: 'absolute',\n          minWidth: '100%',\n          height: '100%',\n          left: 0,\n          right: 0,\n          top: 0,\n          bottom: 0\n        }\n      },\n      buttons: {\n        marginTop: theme.spacing(6),\n        marginBottom: theme.spacing(4)\n      },\n      buttonItem: {\n        cursor: 'pointer',\n        '&:not(:disabled)': {\n          zIndex: 1000\n        }\n      }\n    };\n  });\n};\n\nvar colors = ['#ff8990', '#f7a03e', '#fed853', '#38bb8e', '#139367', '#cef500', '#ffb700', '#ff008f', '#00b4c4', '#ff4040'];\nvar __uid = 0;\n\nvar LadderGame = function LadderGame(props) {\n  var _useLifecycle = useLifecycle({\n    useLog: true,\n    logLabel: 'LadderGame'\n  }),\n      useCreated = _useLifecycle.useCreated,\n      useMounted = _useLifecycle.useMounted,\n      useBeforeDestroy = _useLifecycle.useBeforeDestroy;\n\n  var _useState = useState(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var classes = useStyles(state)();\n  var mapRef = useRef(null);\n  var resultRef = useRef(null);\n  var methods = {\n    calcMapSize: function calcMapSize() {\n      if (mapRef.current) {\n        var _mapRef$current, _mapRef$current2;\n\n        state.mapWidth = ((_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.scrollWidth) || 0;\n        state.mapHeight = Math.max(state.mapHeight, ((_mapRef$current2 = mapRef.current) === null || _mapRef$current2 === void 0 ? void 0 : _mapRef$current2.scrollHeight) || 0);\n        setState(state);\n        return true;\n      } else {\n        return false;\n      }\n    },\n    paintLadder: function paintLadder() {\n      var ladderQty = props.ladderQty;\n      var mapData = state.mapData;\n      state.isPaintingLadder = true;\n\n      for (var x = 0; x < ladderQty; x++) {\n        mapData[x] = [];\n\n        for (var y = 0; y < state.ladderBlockCnt; y++) {\n          mapData[x][y] = methods.createMapData(x, y);\n\n          if (y > 0) {\n            var prev = mapData[x][y - 1];\n            prev.nextBlock = mapData[x][y];\n            mapData[x][y].prevBlock = prev;\n          }\n\n          if (y > 0 && y < state.ladderBlockCnt - 1) {\n            mapData[x][y].isHandle = y % 2 !== 0;\n          }\n        }\n      }\n\n      state.mapData = mapData;\n      state.isPaintingLadder = false;\n      state.isPaintedLadder = true;\n      setState(state);\n    },\n    connectMidLine: function connectMidLine(x, y) {\n      return function (e) {\n        var _state$generatingMidL;\n\n        e.persist();\n        console.group('item');\n        console.log('x', x, 'y', y);\n        console.log(state.mapData[x][y]);\n        console.groupEnd(); // handle만 조작 가능하다\n\n        if (!state.mapData[x][y].isHandle) return; // 이미 연결된건 조작 불가능하다\n\n        if (state.mapData[x][y].isLinked) return; // 같은 block을 클릭하면 취소된다\n\n        if (state.mapData[x][y] === state.generatingMidLinePoint) {\n          setState(_objectSpread({}, state, {\n            generatingMidLinePoint: null\n          }));\n          return;\n        } // 같은 라인의 block을 클릭하면 취소된다\n\n\n        if (x === ((_state$generatingMidL = state.generatingMidLinePoint) === null || _state$generatingMidL === void 0 ? void 0 : _state$generatingMidL.x)) {\n          setState(_objectSpread({}, state, {\n            generatingMidLinePoint: null\n          }));\n          return;\n        } // midLine 시작점을 저장한다\n\n\n        if (!state.generatingMidLinePoint) {\n          setState(_objectSpread({}, state, {\n            generatingMidLinePoint: state.mapData[x][y]\n          }));\n          return;\n        } // midLine을 그린다\n\n\n        if (state.generatingMidLinePoint) {\n          var _startPoint$el, _endPoint$el, _startPoint$el2, _endPoint$el2, _startPoint$el3, _endPoint$el3;\n\n          var defaultMidLineOption = {\n            width: 8\n          };\n          var startPoint = state.generatingMidLinePoint;\n          var endPoint = state.mapData[x][y];\n          var toTheSameTop = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el = startPoint.el) === null || _startPoint$el === void 0 ? void 0 : _startPoint$el.offsetTop) || 0) === ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el = endPoint.el) === null || _endPoint$el === void 0 ? void 0 : _endPoint$el.offsetTop) || 0);\n          var toTheBottom = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el2 = startPoint.el) === null || _startPoint$el2 === void 0 ? void 0 : _startPoint$el2.offsetTop) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el2 = endPoint.el) === null || _endPoint$el2 === void 0 ? void 0 : _endPoint$el2.offsetTop) || 0);\n          var toTheRight = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el3 = startPoint.el) === null || _startPoint$el3 === void 0 ? void 0 : _startPoint$el3.offsetLeft) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el3 = endPoint.el) === null || _endPoint$el3 === void 0 ? void 0 : _endPoint$el3.offsetLeft) || 0);\n          var leftPoint = toTheRight ? startPoint : endPoint;\n          var rightPoint = toTheRight ? endPoint : startPoint;\n\n          if ((leftPoint === null || leftPoint === void 0 ? void 0 : leftPoint.el) !== null && (rightPoint === null || rightPoint === void 0 ? void 0 : rightPoint.el) !== null) {\n            var midLine = {\n              uid: ++__uid,\n              el: null,\n              blocks: [],\n              style: {\n                display: 'block',\n                top: 0,\n                left: 0,\n                width: defaultMidLineOption.width,\n                height: defaultMidLineOption.width,\n                transform: 'rotate(0deg)'\n              }\n            };\n\n            if (toTheSameTop) {\n              var margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n              var addLine = leftPoint.el.offsetWidth - margin * 2;\n              midLine.style.width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine;\n              midLine.style.left = leftPoint.el.offsetLeft + margin;\n              midLine.style.top = leftPoint.el.offsetTop + margin;\n            } else {\n              var _margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n\n              var _addLine = leftPoint.el.offsetWidth - _margin * 2;\n\n              var width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + _addLine;\n\n              var height = Math.abs(leftPoint.el.offsetTop - rightPoint.el.offsetTop) + _addLine;\n\n              var angle = Math.atan(height / width) * 180 / Math.PI;\n              midLine.style.width = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n              midLine.style.left = leftPoint.el.offsetLeft - (midLine.style.width - width) / 2;\n              midLine.style.top = leftPoint.el.offsetTop + height / 2;\n              midLine.style.transform = \"rotate(\".concat(angle, \"deg)\"); // 방향에 따라 추가 연산\n\n              if (!toTheBottom && toTheRight || !toTheRight && toTheBottom) {\n                midLine.style.top += height * -1;\n                midLine.style.transform = \"rotate(\".concat(angle * -1, \"deg)\");\n              }\n\n              if (toTheBottom && toTheRight || !toTheBottom && !toTheRight) {\n                midLine.style.top -= defaultMidLineOption.width / 2;\n              }\n\n              if (!toTheBottom && toTheRight || toTheBottom && !toTheRight) {\n                midLine.style.top += defaultMidLineOption.width / 2;\n              } // margin 추가\n\n\n              midLine.style.left += _margin;\n              midLine.style.top += _margin;\n            } // startPoint, endPoint 서로 연결\n\n\n            startPoint.isLinked = true;\n            endPoint.isLinked = true;\n            startPoint.linkedBlock = endPoint;\n            endPoint.linkedBlock = startPoint;\n            startPoint.midLine = midLine;\n            endPoint.midLine = midLine;\n            midLine.blocks = [startPoint, endPoint]; // state에 저장\n\n            state.midLineData.push(midLine);\n          }\n        } // 수정사항 반영 및 generatingMidLinePoint 초기화\n\n\n        setState(_objectSpread({}, state, {\n          generatingMidLinePoint: null\n        }));\n      };\n    },\n    cutMidLine: function cutMidLine(midLine) {\n      return function () {\n        midLine.blocks.forEach(function (row) {\n          row.isLinked = false;\n          row.linkedBlock = null;\n          row.midLine = null;\n        });\n        var midLineIndex = state.midLineData.findIndex(function (row) {\n          return row.uid === midLine.uid;\n        });\n        state.midLineData.splice(midLineIndex, 1);\n        setState(_objectSpread({}, state));\n      };\n    },\n    bindEl: function bindEl(data) {\n      return function (el) {\n        data.el = el;\n      };\n    },\n    createMapData: function createMapData(x, y) {\n      return {\n        uid: ++__uid,\n        el: null,\n        x: x,\n        y: y,\n        isHandle: false,\n        isLinked: false,\n        prevBlock: null,\n        nextBlock: null,\n        linkedBlock: null,\n        midLine: null\n      };\n    },\n    handleSelectstart: function handleSelectstart(e) {\n      return void e.preventDefault();\n    },\n    playGame: function playGame(key) {\n      return function () {\n        if (resultRef.current && !state.completedLineIndexs.includes(key)) {\n          var canvas = document.createElement('canvas');\n          var ctx = canvas.getContext('2d');\n          canvas.width = state.mapWidth;\n          canvas.height = state.mapHeight;\n\n          if (ctx) {\n            var coordinates = [];\n            var color = colors[state.colorIndex % colors.length];\n            var prevBlockUid = 0;\n            var current = state.mapData[key][0];\n            ctx.lineWidth = 3;\n            ctx.lineJoin = 'round';\n            ctx.strokeStyle = color;\n            ctx.fillStyle = color;\n\n            while (current !== null) {\n              var _current;\n\n              var next = null;\n\n              if (current.nextBlock) {\n                if (coordinates.length === 0) {\n                  var _current$el, _current$el2, _current$el3;\n\n                  // 시작\n                  coordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - ctx.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n                  next = current.nextBlock;\n                } else if (current.linkedBlock) {\n                  if (current.isHandle) {\n                    var _current$el4, _current$el5, _current$el6, _current$el7;\n\n                    coordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - ctx.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - ctx.lineWidth) / 2]);\n                  }\n\n                  if (current.linkedBlock.uid === prevBlockUid) {\n                    // midLine 이동 후\n                    next = current.nextBlock;\n                  } else {\n                    // midLine 이동 전\n                    next = current.linkedBlock;\n                  }\n                } else {\n                  // 일반 block\n                  next = current.nextBlock;\n                }\n              } else {\n                var _current$el8, _current$el9, _current$el10, _current$el11;\n\n                // 끝\n                coordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - ctx.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n              }\n\n              prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n              current = next;\n            }\n\n            for (var index = 0, len = coordinates.length; index < len; index++) {\n              var xy = coordinates[index];\n\n              if (index === 0) {\n                ctx.beginPath();\n                ctx.arc(xy[0], xy[1] - 8, 6, 0, Math.PI * 2);\n                ctx.closePath();\n                ctx.fill();\n                ctx.beginPath();\n                ctx.moveTo(xy[0], xy[1] - 3);\n                ctx.lineTo.apply(ctx, _toConsumableArray(xy));\n              } else {\n                ctx.lineTo.apply(ctx, _toConsumableArray(xy));\n              }\n\n              if (index === len - 1) {\n                ctx.lineTo(xy[0], xy[1] + 3);\n                ctx.stroke();\n                ctx.beginPath();\n                ctx.arc(xy[0], xy[1] + 8, 6, 0, Math.PI * 2);\n                ctx.closePath();\n                ctx.fill();\n              }\n            }\n\n            resultRef.current.append(canvas);\n          }\n\n          state.colorIndex++;\n          state.completedLineIndexs.push(key);\n\n          if (state.completedLineIndexs.length === state.mapData.length) {\n            state.gameStep = 2;\n          }\n\n          setState(_objectSpread({}, state, {\n            gameStep: state.gameStep,\n            completedLineIndexs: state.completedLineIndexs\n          }));\n          return true;\n        } else {\n          return false;\n        }\n      };\n    },\n    doReady: function doReady() {\n      state.gameStep = 1;\n      state.rewards = _toConsumableArray(props.rewards);\n      state.rewards.sort(function () {\n        return Math.random() - Math.random();\n      });\n      setState(_objectSpread({}, state));\n    },\n    reloadGame: function reloadGame() {\n      var prevMidLineData = state.midLineData.splice(0, state.midLineData.length);\n      state.generatingMidLinePoint = null;\n      state.gameStep = 0;\n      state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n      state.colorIndex = 0;\n      prevMidLineData.forEach(function (mapData) {\n        mapData.blocks.forEach(function (block) {\n          block.isLinked = false;\n          block.linkedBlock = null;\n        });\n      });\n\n      if (resultRef.current) {\n        while (resultRef.current.firstChild) {\n          resultRef.current.removeChild(resultRef.current.firstChild);\n        }\n      }\n\n      setState(_objectSpread({}, state));\n    }\n  };\n  useCreated(function _callee() {\n    var _mapRef$current3;\n\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            methods.paintLadder();\n            (_mapRef$current3 = mapRef.current) === null || _mapRef$current3 === void 0 ? void 0 : _mapRef$current3.addEventListener('selectstart', methods.handleSelectstart);\n\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    });\n  });\n  useMounted(function () {\n    methods.calcMapSize();\n    console.log(state);\n  });\n  useBeforeDestroy(function () {\n    var _mapRef$current4;\n\n    (_mapRef$current4 = mapRef.current) === null || _mapRef$current4 === void 0 ? void 0 : _mapRef$current4.removeEventListener('selectstart', methods.handleSelectstart);\n    state.isPaintingLadder = false;\n    state.isPaintedLadder = false;\n    state.mapData.splice(0, state.mapData.length);\n    state.mapWidth = 0;\n    state.mapHeight = defaultOption.mapMinHeight;\n    state.ladderBlockCnt = 21;\n    state.midLineData.splice(0, state.midLineData.length);\n    state.generatingMidLinePoint = null;\n    state.gameStep = 0;\n    state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n    state.colorIndex = 0;\n  });\n  return __jsx(\"div\", {\n    className: classes.root\n  }, function () {\n    if (state.isPaintingLadder) {\n      return __jsx(Typography, null, \"\\uC0AC\\uB2E4\\uB9AC\\uAC00 \\uADF8\\uB824\\uC9C0\\uB294 \\uC911 \\uC785\\uB2C8\\uB2E4. \\uAE30\\uB2E4\\uB824\\uC8FC\\uC138\\uC694.\");\n    } else if (state.isPaintedLadder && !state.isPaintingLadder) {\n      return __jsx(React.Fragment, null, __jsx(\"div\", {\n        className: classes.ladders\n      }, __jsx(Grid, {\n        ref: mapRef,\n        className: classes.ladderContainer,\n        container: true,\n        spacing: 2\n      }, state.mapData.map(function (xVal, xIndex) {\n        return __jsx(Grid, {\n          key: xIndex,\n          item: true\n        }, __jsx(Box, {\n          className: classes.ladderItemHeader\n        }, __jsx(Button, {\n          className: classes.buttonItem,\n          variant: \"contained\",\n          color: \"primary\",\n          onClick: methods.playGame(xIndex),\n          disabled: state.gameStep === 0 || state.completedLineIndexs.includes(xIndex)\n        }, props.players[xIndex] || \"\\uCC38\\uAC00\\uC790 \".concat(xIndex + 1))), __jsx(Box, {\n          className: classes.ladderItem\n        }, xVal.map(function (yVal, yIndex) {\n          var _clsx;\n\n          return __jsx(\"div\", {\n            key: yIndex,\n            ref: methods.bindEl(yVal),\n            className: clsx(classes.ladderItemBlock, (_clsx = {}, _defineProperty(_clsx, classes.ladderItemHandle, yVal.isHandle), _defineProperty(_clsx, \"active\", state.generatingMidLinePoint === yVal), _defineProperty(_clsx, \"linked\", yVal.isLinked), _clsx)),\n            onClick: methods.connectMidLine(xIndex, yIndex)\n          });\n        })), __jsx(Box, {\n          className: classes.ladderItemFooter\n        }, state.gameStep === 0 && __jsx(Typography, null, \"\\uBCF4\\uC0C1 \", xIndex + 1), state.gameStep > 0 && __jsx(Typography, null, state.rewards[xIndex] || \"\\uBCF4\\uC0C1 \".concat(xIndex + 1))));\n      }), state.midLineData.map(function (midLine, midLineIndex) {\n        return __jsx(\"div\", {\n          key: midLineIndex,\n          ref: methods.bindEl(midLine),\n          className: classes.ladderMidLine,\n          style: midLine.style,\n          onClick: methods.cutMidLine(midLine)\n        });\n      }), __jsx(\"div\", {\n        ref: resultRef,\n        className: clsx(classes.result, {\n          active: state.gameStep > 0\n        })\n      }))), __jsx(Grid, {\n        container: true,\n        spacing: 2,\n        className: classes.buttons,\n        justify: \"center\"\n      }, __jsx(Grid, {\n        item: true\n      }, state.gameStep === 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.doReady\n      }, \"\\uC900\\uBE44 \\uC644\\uB8CC\"), state.gameStep > 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.reloadGame,\n        disabled: state.gameStep < 2\n      }, \"\\uB2E4\\uC2DC\\uD558\\uAE30\"))));\n    } else {\n      return null;\n    }\n  }());\n};\n\nexport default LadderGame;","map":null,"metadata":{},"sourceType":"module"}