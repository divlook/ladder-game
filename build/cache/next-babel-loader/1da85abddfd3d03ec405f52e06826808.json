{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { Typography, Box, Grid, Button } from '@material-ui/core';\nimport { useLifecycle } from '~/hooks/lifecycle';\nimport { colors, useStyles } from '~/components/LadderGame.style';\n/*\nTODO:\n\n// 클릭=터치\n// block은 1:1로만 연결가능\n// block이 1:1로 연결되면 midLine이 생성됨.\n// midLine은 [prevStep ,nextStep] 데이터를 가지고 있어야됨. 좌표를 저장하는 방법은 2가지가 있음\n// - 1. useMemo를 사용하여 mapData가 변경될 때마다 새로 계산하는 방법\n// - 2. new Map()을 사용하여 변경할때마다 해당 hash만 변경하는 방법\n// 연결되면 isLinked가 true가 되고 더이상 클릭할 수 없음.\n// midLine을 취소할 수 있으며, 취소하면 원상복귀시켜야 됨.\n// 보상은 midLine이 다 그려진 뒤 게임이 시작되기전에 순서를 랜덤으로 섞어야됨\n// resultLine은 mapData의 0부터 시작해서 nextStep을 따라 그려져야됨\nresultLine이 그려질 때 애니메이션 추가\n결과 데이터 저장\n확률 표시\n\n싱글모드, 멀티모드\n유저정보 입력\n호스트가 게임 생성\n다른 유저들이 게임에 참가\n\nFIXME:\nuseReducer로 변경하고 파일 분리\nmethods는 useCallback 또는 action으로 분리\n*/\n\nexport const defaultOption = {\n  mapMinHeight: 300\n};\nexport const initialState = {\n  isPaintingLadder: false,\n  isPaintedLadder: false,\n  mapData: [],\n  mapWidth: 0,\n  mapHeight: defaultOption.mapMinHeight,\n  ladderBlockCnt: 21,\n  midLineData: [],\n  generatingMidLinePoint: null,\n  gameStep: 0,\n  completedLineIndexs: [],\n  colorIndex: 0,\n  rewards: []\n};\nlet __uid = 0;\n\nconst LadderGame = props => {\n  const {\n    useCreated,\n    useMounted,\n    useBeforeDestroy\n  } = useLifecycle({\n    useLog: true,\n    logLabel: 'LadderGame'\n  });\n  const {\n    0: state,\n    1: setState\n  } = useState(initialState);\n  const classes = useStyles(state)();\n  const mapRef = useRef(null);\n  const resultRef = useRef(null);\n  const methods = {\n    calcMapSize() {\n      if (mapRef.current) {\n        var _mapRef$current, _mapRef$current2;\n\n        state.mapWidth = ((_mapRef$current = mapRef.current) === null || _mapRef$current === void 0 ? void 0 : _mapRef$current.scrollWidth) || 0;\n        state.mapHeight = Math.max(state.mapHeight, ((_mapRef$current2 = mapRef.current) === null || _mapRef$current2 === void 0 ? void 0 : _mapRef$current2.scrollHeight) || 0);\n        setState(state);\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    paintLadder() {\n      const {\n        ladderQty\n      } = props;\n      const {\n        mapData\n      } = state;\n      state.isPaintingLadder = true;\n\n      for (let x = 0; x < ladderQty; x++) {\n        mapData[x] = [];\n\n        for (let y = 0; y < state.ladderBlockCnt; y++) {\n          mapData[x][y] = methods.createMapData(x, y);\n\n          if (y > 0) {\n            const prev = mapData[x][y - 1];\n            prev.nextBlock = mapData[x][y];\n            mapData[x][y].prevBlock = prev;\n          }\n\n          if (y > 0 && y < state.ladderBlockCnt - 1) {\n            mapData[x][y].isHandle = y % 2 !== 0;\n          }\n        }\n      }\n\n      state.mapData = mapData;\n      state.isPaintingLadder = false;\n      state.isPaintedLadder = true;\n      setState(state);\n    },\n\n    calcMidLineStyle: (startPoint, endPoint) => {\n      var _startPoint$el, _endPoint$el, _startPoint$el2, _endPoint$el2, _startPoint$el3, _endPoint$el3;\n\n      const toTheSameTop = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el = startPoint.el) === null || _startPoint$el === void 0 ? void 0 : _startPoint$el.offsetTop) || 0) === ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el = endPoint.el) === null || _endPoint$el === void 0 ? void 0 : _endPoint$el.offsetTop) || 0);\n      const toTheBottom = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el2 = startPoint.el) === null || _startPoint$el2 === void 0 ? void 0 : _startPoint$el2.offsetTop) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el2 = endPoint.el) === null || _endPoint$el2 === void 0 ? void 0 : _endPoint$el2.offsetTop) || 0);\n      const toTheRight = ((startPoint === null || startPoint === void 0 ? void 0 : (_startPoint$el3 = startPoint.el) === null || _startPoint$el3 === void 0 ? void 0 : _startPoint$el3.offsetLeft) || 0) < ((endPoint === null || endPoint === void 0 ? void 0 : (_endPoint$el3 = endPoint.el) === null || _endPoint$el3 === void 0 ? void 0 : _endPoint$el3.offsetLeft) || 0);\n      const leftPoint = toTheRight ? startPoint : endPoint;\n      const rightPoint = toTheRight ? endPoint : startPoint;\n\n      if ((leftPoint === null || leftPoint === void 0 ? void 0 : leftPoint.el) !== null && (rightPoint === null || rightPoint === void 0 ? void 0 : rightPoint.el) !== null) {\n        const defaultMidLineOption = {\n          width: 8\n        };\n        const style = {\n          display: 'block',\n          top: 0,\n          left: 0,\n          width: defaultMidLineOption.width,\n          height: defaultMidLineOption.width,\n          transform: 'rotate(0deg)'\n        };\n\n        if (toTheSameTop) {\n          const margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n          const addLine = leftPoint.el.offsetWidth - margin * 2;\n          style.width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine;\n          style.left = leftPoint.el.offsetLeft + margin;\n          style.top = leftPoint.el.offsetTop + margin;\n        } else {\n          const margin = (leftPoint.el.offsetWidth - defaultMidLineOption.width) / 2;\n          const addLine = leftPoint.el.offsetWidth - margin * 2;\n          const width = Math.abs(leftPoint.el.offsetLeft - rightPoint.el.offsetLeft) + addLine;\n          const height = Math.abs(leftPoint.el.offsetTop - rightPoint.el.offsetTop) + addLine;\n          const angle = Math.atan(height / width) * 180 / Math.PI;\n          style.width = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n          style.left = leftPoint.el.offsetLeft - (style.width - width) / 2;\n          style.top = leftPoint.el.offsetTop + height / 2;\n          style.transform = `rotate(${angle}deg)`; // 방향에 따라 추가 연산\n\n          if (!toTheBottom && toTheRight || !toTheRight && toTheBottom) {\n            style.top += height * -1;\n            style.transform = `rotate(${angle * -1}deg)`;\n          }\n\n          if (toTheBottom && toTheRight || !toTheBottom && !toTheRight) {\n            style.top -= defaultMidLineOption.width / 2;\n          }\n\n          if (!toTheBottom && toTheRight || toTheBottom && !toTheRight) {\n            style.top += defaultMidLineOption.width / 2;\n          } // margin 추가\n\n\n          style.left += margin;\n          style.top += margin;\n        }\n\n        return style;\n      }\n\n      return undefined;\n    },\n    connectMidLine: (x, y) => e => {\n      var _state$generatingMidL;\n\n      e.persist();\n      console.group('item');\n      console.log('x', x, 'y', y);\n      console.log(state.mapData[x][y]);\n      console.groupEnd(); // handle만 조작 가능하다\n\n      if (!state.mapData[x][y].isHandle) return; // 이미 연결된건 조작 불가능하다\n\n      if (state.mapData[x][y].isLinked) return; // 같은 block을 클릭하면 취소된다\n\n      if (state.mapData[x][y] === state.generatingMidLinePoint) {\n        setState(_objectSpread({}, state, {\n          generatingMidLinePoint: null\n        }));\n        return;\n      } // 같은 라인의 block을 클릭하면 취소된다\n\n\n      if (x === ((_state$generatingMidL = state.generatingMidLinePoint) === null || _state$generatingMidL === void 0 ? void 0 : _state$generatingMidL.x)) {\n        setState(_objectSpread({}, state, {\n          generatingMidLinePoint: null\n        }));\n        return;\n      } // midLine 시작점을 저장한다\n\n\n      if (!state.generatingMidLinePoint) {\n        setState(_objectSpread({}, state, {\n          generatingMidLinePoint: state.mapData[x][y]\n        }));\n        return;\n      } // midLine을 그린다\n\n\n      if (state.generatingMidLinePoint) {\n        const midLine = {\n          uid: ++__uid,\n          el: null,\n          blocks: [],\n          style: undefined\n        };\n        const startPoint = state.generatingMidLinePoint;\n        const endPoint = state.mapData[x][y]; // startPoint, endPoint 서로 연결\n\n        startPoint.isLinked = true;\n        endPoint.isLinked = true;\n        startPoint.linkedBlock = endPoint;\n        endPoint.linkedBlock = startPoint;\n        startPoint.midLine = midLine;\n        endPoint.midLine = midLine;\n        midLine.blocks = [startPoint, endPoint];\n        midLine.style = methods.calcMidLineStyle(startPoint, endPoint); // state에 저장\n\n        state.midLineData.push(midLine);\n      } // 수정사항 반영 및 generatingMidLinePoint 초기화\n\n\n      setState(_objectSpread({}, state, {\n        generatingMidLinePoint: null\n      }));\n    },\n    cutMidLine: midLine => () => {\n      midLine.blocks.forEach(row => {\n        row.isLinked = false;\n        row.linkedBlock = null;\n        row.midLine = null;\n      });\n      const midLineIndex = state.midLineData.findIndex(row => row.uid === midLine.uid);\n      state.midLineData.splice(midLineIndex, 1);\n      setState(_objectSpread({}, state));\n    },\n    bindEl: data => el => {\n      data.el = el;\n    },\n\n    createMapData(x, y) {\n      return {\n        uid: ++__uid,\n        el: null,\n        x,\n        y,\n        isHandle: false,\n        isLinked: false,\n        prevBlock: null,\n        nextBlock: null,\n        linkedBlock: null,\n        midLine: null\n      };\n    },\n\n    playGame: key => () => {\n      if (resultRef.current && !state.completedLineIndexs.includes(key)) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = state.mapWidth;\n        canvas.height = state.mapHeight;\n\n        if (ctx) {\n          const coordinates = [];\n          const color = colors[state.colorIndex % colors.length];\n          let prevBlockUid = 0;\n          let current = state.mapData[key][0];\n          ctx.lineWidth = 3;\n          ctx.lineJoin = 'round';\n          ctx.strokeStyle = color;\n          ctx.fillStyle = color;\n\n          while (current !== null) {\n            var _current;\n\n            let next = null;\n\n            if (current.nextBlock) {\n              if (coordinates.length === 0) {\n                var _current$el, _current$el2, _current$el3;\n\n                // 시작\n                coordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - ctx.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n                next = current.nextBlock;\n              } else if (current.linkedBlock) {\n                if (current.isHandle) {\n                  var _current$el4, _current$el5, _current$el6, _current$el7;\n\n                  coordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - ctx.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - ctx.lineWidth) / 2]);\n                }\n\n                if (current.linkedBlock.uid === prevBlockUid) {\n                  // midLine 이동 후\n                  next = current.nextBlock;\n                } else {\n                  // midLine 이동 전\n                  next = current.linkedBlock;\n                }\n              } else {\n                // 일반 block\n                next = current.nextBlock;\n              }\n            } else {\n              var _current$el8, _current$el9, _current$el10, _current$el11;\n\n              // 끝\n              coordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - ctx.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n            }\n\n            prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n            current = next;\n          }\n\n          for (let index = 0, len = coordinates.length; index < len; index++) {\n            const xy = coordinates[index];\n\n            if (index === 0) {\n              ctx.beginPath();\n              ctx.arc(xy[0], xy[1] - 8, 6, 0, Math.PI * 2);\n              ctx.closePath();\n              ctx.fill();\n              ctx.beginPath();\n              ctx.moveTo(xy[0], xy[1] - 3);\n              ctx.lineTo(...xy);\n            } else {\n              ctx.lineTo(...xy);\n            }\n\n            if (index === len - 1) {\n              ctx.lineTo(xy[0], xy[1] + 3);\n              ctx.stroke();\n              ctx.beginPath();\n              ctx.arc(xy[0], xy[1] + 8, 6, 0, Math.PI * 2);\n              ctx.closePath();\n              ctx.fill();\n            }\n          }\n\n          resultRef.current.append(canvas);\n        }\n\n        state.colorIndex++;\n        state.completedLineIndexs.push(key);\n\n        if (state.completedLineIndexs.length === state.mapData.length) {\n          state.gameStep = 2;\n        }\n\n        setState(_objectSpread({}, state, {\n          gameStep: state.gameStep,\n          completedLineIndexs: state.completedLineIndexs\n        }));\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    doReady() {\n      state.gameStep = 1;\n      state.rewards = [...props.rewards];\n      state.rewards.sort(() => Math.random() - Math.random());\n      setState(_objectSpread({}, state));\n    },\n\n    reGame() {\n      const prevMidLineData = state.midLineData.splice(0, state.midLineData.length);\n      state.generatingMidLinePoint = null;\n      state.gameStep = 0;\n      state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n      state.colorIndex = 0;\n      prevMidLineData.forEach(mapData => {\n        mapData.blocks.forEach(block => {\n          block.isLinked = false;\n          block.linkedBlock = null;\n        });\n      });\n\n      if (resultRef.current) {\n        while (resultRef.current.firstChild) {\n          resultRef.current.removeChild(resultRef.current.firstChild);\n        }\n      }\n\n      setState(_objectSpread({}, state));\n    },\n\n    handleOrientationchange: () => {\n      if (methods.calcMapSize()) {\n        // TODO: 회전시 midLine의 위치와 canvas가 갱신은 되나 게임이 처음부터 다시 시작되는 버그가 생김\n        setState(prevState => _objectSpread({}, prevState, {\n          midLineData: state.midLineData.map(midLine => {\n            midLine.style = methods.calcMidLineStyle(midLine.blocks[0], midLine.blocks[1]);\n            return midLine;\n          })\n        }));\n      }\n    }\n  };\n  useCreated(async () => {\n    methods.paintLadder();\n    window.addEventListener('orientationchange', methods.handleOrientationchange); // window.addEventListener('resize', () => { console.log('resize') })\n  });\n  useMounted(() => {\n    methods.calcMapSize();\n    console.log(state);\n  });\n  useBeforeDestroy(() => {\n    window.removeEventListener('orientationchange', methods.handleOrientationchange);\n    state.isPaintingLadder = false;\n    state.isPaintedLadder = false;\n    state.mapData.splice(0, state.mapData.length);\n    state.mapWidth = 0;\n    state.mapHeight = defaultOption.mapMinHeight;\n    state.ladderBlockCnt = 21;\n    state.midLineData.splice(0, state.midLineData.length);\n    state.generatingMidLinePoint = null;\n    state.gameStep = 0;\n    state.completedLineIndexs.splice(0, state.completedLineIndexs.length);\n    state.colorIndex = 0;\n  });\n  return __jsx(\"div\", {\n    className: classes.root\n  }, (() => {\n    if (state.isPaintingLadder) {\n      return __jsx(Typography, null, \"\\uC0AC\\uB2E4\\uB9AC\\uAC00 \\uADF8\\uB824\\uC9C0\\uB294 \\uC911 \\uC785\\uB2C8\\uB2E4. \\uAE30\\uB2E4\\uB824\\uC8FC\\uC138\\uC694.\");\n    } else if (state.isPaintedLadder && !state.isPaintingLadder) {\n      return __jsx(React.Fragment, null, __jsx(\"div\", {\n        className: classes.ladders\n      }, __jsx(Grid, {\n        ref: mapRef,\n        className: classes.ladderContainer,\n        container: true,\n        spacing: 2\n      }, state.mapData.map((xVal, xIndex) => {\n        return __jsx(Grid, {\n          key: xIndex,\n          item: true\n        }, __jsx(Box, {\n          className: classes.ladderItemHeader\n        }, __jsx(Button, {\n          className: classes.buttonItem,\n          variant: \"contained\",\n          color: \"primary\",\n          onClick: methods.playGame(xIndex),\n          disabled: state.gameStep === 0 || state.completedLineIndexs.includes(xIndex)\n        }, props.players[xIndex] || `참가자 ${xIndex + 1}`)), __jsx(Box, {\n          className: classes.ladderItem\n        }, xVal.map((yVal, yIndex) => {\n          return __jsx(\"div\", {\n            key: yIndex,\n            ref: methods.bindEl(yVal),\n            className: clsx(classes.ladderItemBlock, {\n              [classes.ladderItemHandle]: yVal.isHandle,\n              active: state.generatingMidLinePoint === yVal,\n              linked: yVal.isLinked\n            }),\n            onClick: methods.connectMidLine(xIndex, yIndex)\n          });\n        })), __jsx(Box, {\n          className: classes.ladderItemFooter\n        }, state.gameStep === 0 && __jsx(Typography, null, \"\\uBCF4\\uC0C1 \", xIndex + 1), state.gameStep > 0 && __jsx(Typography, null, state.rewards[xIndex] || `보상 ${xIndex + 1}`)));\n      }), state.midLineData.map((midLine, midLineIndex) => {\n        return __jsx(\"div\", {\n          key: midLineIndex,\n          ref: methods.bindEl(midLine),\n          className: classes.ladderMidLine,\n          style: midLine.style,\n          onClick: methods.cutMidLine(midLine)\n        });\n      }), __jsx(\"div\", {\n        ref: resultRef,\n        className: clsx(classes.result, {\n          active: state.gameStep > 0\n        })\n      }))), __jsx(Grid, {\n        container: true,\n        spacing: 2,\n        className: classes.buttons,\n        justify: \"center\"\n      }, __jsx(Grid, {\n        item: true\n      }, state.gameStep === 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.doReady\n      }, \"\\uC900\\uBE44 \\uC644\\uB8CC\"), state.gameStep > 0 && __jsx(Button, {\n        className: classes.buttonItem,\n        variant: \"contained\",\n        color: \"secondary\",\n        size: \"large\",\n        onClick: methods.reGame,\n        disabled: state.gameStep < 2\n      }, \"\\uB2E4\\uC2DC\\uD558\\uAE30\"))));\n    } else {\n      return null;\n    }\n  })());\n};\n\nexport default LadderGame;","map":null,"metadata":{},"sourceType":"module"}