{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport { colors } from '~/components/LadderGame.style';\n\nconst ResultCanvas = props => {\n  const canvasRef = useRef(null);\n  const {\n    width,\n    height,\n    lineIndex,\n    map\n  } = props;\n  const {\n    0: state,\n    1: setState\n  } = useState(() => {\n    return {\n      coordinates: [],\n      lineWidth: 3,\n      animations: []\n    };\n  });\n  useEffect(() => {\n    calcCoordinates();\n  }, [width, height, lineIndex, map]);\n  useEffect(() => {\n    makeAnimations();\n  }, [state.coordinates]);\n  useEffect(() => {\n    drawCanvas(true);\n  }, [state.animations]);\n  const calcCoordinates = useCallback(() => {\n    const nextCoordinates = [];\n    let prevBlockUid = 0;\n    let current = map[lineIndex][0];\n\n    while (current !== null) {\n      var _current;\n\n      let next = null;\n\n      if (current.nextBlock) {\n        if (nextCoordinates.length === 0) {\n          var _current$el, _current$el2, _current$el3;\n\n          // 시작\n          nextCoordinates.push([(((_current$el = current.el) === null || _current$el === void 0 ? void 0 : _current$el.offsetLeft) || 0) + (((_current$el2 = current.el) === null || _current$el2 === void 0 ? void 0 : _current$el2.offsetWidth) || 0 - state.lineWidth) / 2, ((_current$el3 = current.el) === null || _current$el3 === void 0 ? void 0 : _current$el3.offsetTop) || 0]);\n          next = current.nextBlock;\n        } else if (current.linkedBlock) {\n          if (current.isHandle) {\n            var _current$el4, _current$el5, _current$el6, _current$el7;\n\n            nextCoordinates.push([(((_current$el4 = current.el) === null || _current$el4 === void 0 ? void 0 : _current$el4.offsetLeft) || 0) + (((_current$el5 = current.el) === null || _current$el5 === void 0 ? void 0 : _current$el5.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el6 = current.el) === null || _current$el6 === void 0 ? void 0 : _current$el6.offsetTop) || 0) + (((_current$el7 = current.el) === null || _current$el7 === void 0 ? void 0 : _current$el7.offsetHeight) || 0 - state.lineWidth) / 2]);\n          }\n\n          if (current.linkedBlock.uid === prevBlockUid) {\n            // midLine 이동 후\n            next = current.nextBlock;\n          } else {\n            // midLine 이동 전\n            next = current.linkedBlock;\n          }\n        } else {\n          // 일반 block\n          next = current.nextBlock;\n        }\n      } else {\n        var _current$el8, _current$el9, _current$el10, _current$el11;\n\n        // 끝\n        nextCoordinates.push([(((_current$el8 = current.el) === null || _current$el8 === void 0 ? void 0 : _current$el8.offsetLeft) || 0) + (((_current$el9 = current.el) === null || _current$el9 === void 0 ? void 0 : _current$el9.offsetWidth) || 0 - state.lineWidth) / 2, (((_current$el10 = current.el) === null || _current$el10 === void 0 ? void 0 : _current$el10.offsetTop) || 0) + (((_current$el11 = current.el) === null || _current$el11 === void 0 ? void 0 : _current$el11.offsetHeight) || 0)]);\n      }\n\n      prevBlockUid = ((_current = current) === null || _current === void 0 ? void 0 : _current.uid) || 0;\n      current = next;\n    }\n\n    setState(prevState => {\n      return _objectSpread({}, prevState, {\n        coordinates: [...nextCoordinates]\n      });\n    });\n  }, [lineIndex, map]);\n  const makeAnimations = useCallback(() => {\n    if (!canvasRef.current || !width || !height) return;\n    canvasRef.current.width = width;\n    canvasRef.current.height = height;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    const color = colors[lineIndex % colors.length];\n    if (!ctx) return;\n    const lastIndex = state.coordinates.length - 1;\n\n    const waypointMapper = waypoints => isEnd => {\n      // const prev = waypoints[0]\n      const next = waypoints[1];\n      ctx.lineTo(...next);\n      isEnd && ctx.stroke();\n    };\n\n    ctx.lineWidth = state.lineWidth;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round';\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    const animations = state.coordinates.reduce((result, currentCoordinate, index) => {\n      const prevCoordinate = state.coordinates[index - 1];\n\n      if (index === 0) {\n        result.push(() => {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] - 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n          ctx.beginPath();\n        });\n        result = result.concat(calcWaypoints([currentCoordinate[0], currentCoordinate[1] - 3], currentCoordinate).map(waypointMapper));\n      }\n\n      if (prevCoordinate) {\n        result = result.concat(calcWaypoints(prevCoordinate, currentCoordinate).map(waypointMapper));\n      }\n\n      if (index === lastIndex) {\n        result = result.concat(calcWaypoints(currentCoordinate, [currentCoordinate[0], currentCoordinate[1] + 3]).map(waypointMapper));\n        result.push(() => {\n          ctx.stroke();\n          ctx.closePath();\n          ctx.beginPath();\n          ctx.arc(currentCoordinate[0], currentCoordinate[1] + 8, 6, 0, Math.PI * 2);\n          ctx.closePath();\n          ctx.fill();\n        });\n      }\n\n      return result;\n    }, []);\n    setState(prevState => _objectSpread({}, prevState, {\n      animations: [...animations]\n    }));\n  }, [state.lineWidth, state.coordinates, width, height, lineIndex]);\n  const calcWaypoints = useCallback((start, end) => {\n    const waypoints = [];\n    const dx = end[0] - start[0];\n    const dy = end[1] - start[1];\n    const frames = Math.round(Math.cbrt(Math.pow(Math.abs(dx), 2) + Math.pow(Math.abs(dy), 2))) * 1.2;\n    let prevWaypoint = null;\n\n    for (let i = 0; i < frames; i++) {\n      const x = start[0] + dx * i / frames;\n      const y = start[1] + dy * i / frames;\n      const waypoint = [x, y];\n      if (prevWaypoint) waypoints.push([prevWaypoint, waypoint]);\n      prevWaypoint = waypoint;\n    }\n\n    return waypoints;\n  }, []);\n  const drawCanvas = useCallback((useAnimation = false, playIndex = 0) => {\n    for (const index in state.animations) {\n      const isEnd = playIndex <= index;\n      const animationCallback = state.animations[index];\n      animationCallback === null || animationCallback === void 0 ? void 0 : animationCallback(isEnd);\n      if (isEnd) break;\n    }\n\n    playIndex++;\n\n    if (useAnimation) {\n      requestAnimationFrame(() => drawCanvas(useAnimation, playIndex));\n    } else {\n      drawCanvas(useAnimation, playIndex);\n    }\n  }, [state.animations]);\n  return __jsx(\"canvas\", {\n    ref: canvasRef,\n    width: width,\n    height: height\n  });\n};\n\nexport default ResultCanvas;","map":null,"metadata":{},"sourceType":"module"}